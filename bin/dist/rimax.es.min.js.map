{"version":3,"file":"rimax.es.min.js","sources":["../../Rimax/hooks/useState.js","../../Rimax/hooks/useRef.js","../../Rimax/hooks/useEffect.js","../../Rimax/hooks/useLayoutEffect.js","../../Rimax/hooks/useProps.js","../../Rimax/hooks/useEvent.js","../../Rimax/hooks/useMemo.js","../../Rimax/core/domController.js","../../Rimax/core/rxError.js","../../Rimax/core/RgExp.js","../../Rimax/core/templateRef.js","../../Rimax/core/RxFiber/FiberOfNode.js","../../Rimax/core/RxFiber/FiberOfElement.js","../../Rimax/core/RxFiber/FiberOfFragment.js","../../Rimax/core/RxFiber/FiberOfText.js","../../Rimax/core/core.js","../../Rimax/core/component.js","../../Rimax/core/customeElement.js","../../Rimax/core/RcHtmlString/HtmlStringParser.js","../../Rimax/core/RcHtmlString/RcHtmlString.js","../../Rimax/index.js"],"sourcesContent":["const guardFn = v => v\r\nconst stateSymbol = Symbol(\"$$State\")\r\nconst isState = ((ref) => (typeof ref == \"object\") && stateSymbol === ref[\".rxType\"]).bind()\r\nexport class RXState {\r\n    get isArray() { return Array.isArray(this.value) }\r\n    toString() { return String(this.value) }\r\n    valueOf() { return this.value }\r\n    get [\".rxType\"]() { return stateSymbol }\r\n    static isState = isState\r\n}\r\nfunction createState(value, guard) {\r\n    let currentValueOfState\r\n    let oldValueOfState\r\n    let isDestroyed = false\r\n    let subscriber=0\r\n    const ID = Math.random()\r\n    const GUARDS = []\r\n    const DESTROY_EVENTS = new Set()\r\n    const UPDATE_EVENTS = new Set()\r\n    const ACTIONS={}\r\n    const dispatchUpdate = (option) => { UPDATE_EVENTS.forEach(fn =>fn(currentValueOfState, oldValueOfState, option)) }\r\n    \r\n    return Object.freeze(new (class rxState extends RXState {\r\n        get guards() { return [...GUARDS] }\r\n        get isDestroyed() { return isDestroyed }\r\n        get id() { return ID }\r\n        get len() { return {onChange:UPDATE_EVENTS.size,onCleanup:DESTROY_EVENTS.size,subscriber} }\r\n        addGuard(guard) {\r\n            if (!(guard instanceof Function)) return () => undefined\r\n            const callback = (...a) => guard(...a)\r\n            const lastIndex = GUARDS.push(callback) - 1\r\n            let isRemoved = false\r\n            return () => {\r\n                if (isRemoved) return true\r\n                if (GUARDS[lastIndex] === callback) {\r\n                    GUARDS.splice(lastIndex, 1)\r\n                    isRemoved = true\r\n                    return true\r\n                }\r\n                const i = GUARDS.find(fn => fn === callback)\r\n                if (i > -1) {\r\n                    GUARDS.splice(i, 1)\r\n                    return true\r\n                }\r\n                return false\r\n            }\r\n        }\r\n\r\n        clear(withDom = false) {\r\n            DESTROY_EVENTS.forEach(fn => fn(withDom))\r\n            DESTROY_EVENTS.clear()\r\n            UPDATE_EVENTS.clear()\r\n        }\r\n        destroy(withDom = true) {\r\n            if (isDestroyed) return;\r\n            this.clear(withDom)\r\n            isDestroyed = true\r\n        }\r\n\r\n        onChange = ((callbackOrState, directApply = false) => {\r\n            if (callbackOrState instanceof RXState) {\r\n                const callback = directApply instanceof Function ? directApply : v => v\r\n                const state=callbackOrState\r\n                subscriber++\r\n                let isRemoved\r\n                return this.onChange((...args) =>{\r\n                    state.set(() => callback(...args), ...args.slice(1))\r\n                    return ()=>{\r\n                        if(isRemoved) return\r\n                        isRemoved=true\r\n                        subscriber--\r\n                    }\r\n                }, true)\r\n            }\r\n            if (!(callbackOrState instanceof Function)) throw new Error(\"callback doit être une fonction\")\r\n            const on = {\r\n                dispatch: callbackOrState, destroy: directApply ? callbackOrState(this.value, undefined, { methode: \"set\", value: this.value }) : undefined\r\n            }\r\n            const onDispatch = (...arg) => on.destroy = on.dispatch(...arg)\r\n            let isCalled = false\r\n            const destroy = (...arg) => {\r\n                if (isCalled) return\r\n                isCalled = true\r\n                if (on.destroy instanceof Function) on.destroy(...arg);\r\n                DESTROY_EVENTS.delete(destroy)\r\n                UPDATE_EVENTS.delete(onDispatch)\r\n            }\r\n            UPDATE_EVENTS.add(onDispatch)\r\n            DESTROY_EVENTS.add(destroy)\r\n            return destroy\r\n        }).bind()\r\n        onCleanup = ((callback) => {\r\n            if (!(callback instanceof Function)) throw new Error(\"callback doit être une fonction\")\r\n            const fn=(...args)=>callback(...args)\r\n            DESTROY_EVENTS.add(fn)\r\n            return () => DESTROY_EVENTS.delete(callback)\r\n        }).bind()\r\n\r\n\r\n        get oldValue() { return oldValueOfState }\r\n\r\n        constructor(value, guard = v => v) {\r\n            super()\r\n            Object.defineProperty(this, \"value\", {\r\n                get: (() => currentValueOfState).bind(),\r\n                set: ((value) => this.set(value)).bind(),\r\n                enumerable: true,\r\n            })\r\n            if(guard&& typeof guard ==\"object\"){\r\n                Object.assign(ACTIONS,guard.actions??{})\r\n                guard=guard.guard??(v => v)\r\n            }\r\n            if (!(guard instanceof Function)) throw new Error(\"guard doit être une fonction\")\r\n            currentValueOfState = value\r\n            GUARDS.push(guard)\r\n            const toValidate = (value, oldValue = oldValueOfState, option = {}) => {\r\n                const oldValues = []\r\n                return GUARDS.reduceRight((val, guardFn) => {\r\n                    oldValues.push(val)\r\n                    return guardFn(val, oldValue, option, [...oldValues])\r\n                }, value)\r\n            }\r\n            if (!(value instanceof Promise)) {\r\n                currentValueOfState = toValidate(value, undefined, {})\r\n            }\r\n            const createStateComputed = (callback = () => currentValueOfState, dependencies = [], guard = v => v) => {\r\n                if (!(callback instanceof Function)) throw new Error(\"callback doit être une function\")\r\n                if (isDestroyed) throw new Error(\"cette Etat ne peut plus etre utiliser car elle est deja detruit\")\r\n                const optDependencies=(dependencies&&!Array.isArray(dependencies)&&typeof dependencies==\"object\")?dependencies:{}\r\n                dependencies=Array.isArray(dependencies)?dependencies:optDependencies.dependencies??[]\r\n                if (!Array.isArray(dependencies)) throw new Error(\"dependencies doit être une Array\")\r\n                const update = (option = {}) => callback(currentValueOfState, oldValueOfState, option)\r\n                const optionState={guard,...optDependencies}\r\n                const [state, setState] = useState(update(), optionState)\r\n                if(optionState.guard!==guard)state.addGuard(guard);\r\n                const states = [this, ...dependencies]\r\n                const listrmv = states.map(st => {\r\n                    if (st instanceof RXState) {\r\n                        return st.onChange((_1, _2, option) => {\r\n                            setState(update(option), option)\r\n                            return () => !state.isDestroyed && state.destroy(true)\r\n                        })\r\n                    }\r\n                })\r\n                state.onCleanup(() => listrmv.map(fn => fn instanceof Function && fn()))\r\n                return state\r\n            }\r\n            this.get = ((callback = () => this.value, dependencies = []) => createStateComputed(callback, dependencies)).bind()\r\n            Object.entries(stateType).map(([type, fnGuard]) => this.get[type] = (callback = () => this.value, dependencies = []) => createStateComputed(callback, dependencies, fnGuard))\r\n            this.set = ((value, option = { methode: \"set\", value: value }) => {\r\n                if (isDestroyed) throw new Error(\"cette Etat ne peut plus etre utiliser car elle est deja detruit\")\r\n                if (typeof option != \"object\") throw new Error(\"option doit être un object\")\r\n                if (value instanceof Promise) {\r\n                    return value.then(v => this.set(v))\r\n                }\r\n                if (value instanceof RXState) value = value.value;\r\n                if (value instanceof Function) value = value(currentValueOfState, oldValueOfState)\r\n                const _oldValue = currentValueOfState\r\n                if (_oldValue !== value) {\r\n                    value = toValidate(value, _oldValue, option);\r\n                    oldValueOfState = _oldValue\r\n                    currentValueOfState = value\r\n                    dispatchUpdate(option)\r\n                }\r\n                return currentValueOfState\r\n            }).bind()\r\n            insertArrayMethode(this, { createStateComputed })\r\n            Object.entries(ACTIONS).map(([k,v])=>this.set[k]=payload=>this.set(v instanceof Function ?v(currentValueOfState,payload):v))\r\n            if (value instanceof Promise) {\r\n                value.then(v => this.set(v))\r\n            }\r\n        }\r\n\r\n    })(value, guard))\r\n}\r\nconst stateType = {\r\n    array(v) {\r\n        if (!Array.isArray(v)) throw new Error(\"cette state doit être de type Array\")\r\n        return v\r\n    },\r\n    number(v) {\r\n        if (typeof v != \"number\") throw new Error(\"cette state doit être de type Number\")\r\n        return v\r\n    },\r\n    string(v) {\r\n        if (typeof v != \"string\") throw new Error(\"cette state doit être de type string\")\r\n        return v\r\n    },\r\n    function(v) {\r\n        if (typeof v != \"function\") throw new Error(\"cette state doit être de type function\")\r\n        return v\r\n    },\r\n    boolean(v) {\r\n        if (typeof v != \"boolean\") throw new Error(\"cette state doit être de type boolean\")\r\n        return v\r\n    },\r\n    symbol(v) {\r\n        if (typeof v != \"symbol\") throw new Error(\"cette state doit être de type symbol\")\r\n        return v\r\n    },\r\n    object(v) {\r\n        if (typeof v != \"object\") throw new Error(\"cette state doit être de type object\")\r\n        return v\r\n    },\r\n}\r\nfunction insertArrayMethode(stateInstace, { createStateComputed }) {\r\n    const state = stateInstace\r\n    const isArray = () => {\r\n        if (!state.isArray) throw new Error(\"pour pouvoir utiliser cette methode le type de state doit être une Array\")\r\n    }\r\n    const isFunction = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit doit être une function\")\r\n    }\r\n    const getIndex = (index) => {\r\n        if (index instanceof RXState) {\r\n            index = index.value\r\n        }\r\n        if (index instanceof Function) {\r\n            index = state.value.findIndex(index)\r\n        }\r\n        if (isNaN(index)) throw new Error(\"index doit être une nombre ou une fonction qui retourne un nombre\")\r\n        return index\r\n    }\r\n    state.get.map = (callback) => {\r\n        isFunction(callback)\r\n        const createState = (v, i) => [useState(v)[0], useState(i)[0]]\r\n        const rendMap = (v) => callback(...v, state)\r\n        const listState = state.value.map(createState)\r\n        let listElement = listState.map(rendMap)\r\n        const [items, setItems] = useState(listElement)\r\n        const update = () => listState.map(([v, i], index) => {\r\n            if (!i.isDestroyed) i.set(index);\r\n            if (!v.isDestroyed) v.set(state.value[index]);\r\n        })\r\n        state.onChange((val) => {\r\n            if (listState.length > val.length) {\r\n                const indexStart = val.length\r\n                const end = listState.length\r\n                listState.splice(indexStart, end).map(s => s.map(i => i.destroy(true)))\r\n                setItems.splice(indexStart, end)\r\n            } else if (listState.length < val.length) {\r\n                const indexStart = listState.length\r\n                listState.push(...val.slice(indexStart).map(createState))\r\n                listState.map(([, index], i) => index.set(i))\r\n                setItems.push(...listState.slice(indexStart).map(rendMap))\r\n            }\r\n            update()\r\n            // console.log(items.value);\r\n        })\r\n        return items\r\n    }\r\n    state.get.callback = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit être une function\")\r\n        return state.get(() => callback)\r\n    }\r\n    const action = (args, action) => {\r\n        isArray()\r\n        if (state.value[action] instanceof Function) {\r\n            const returnValue = state.value[action](...args)\r\n            return state.set([...state.value], { methode: \"set\", action, args, returnValue })\r\n        }\r\n    }\r\n    // TODO: state.set.remove\r\n    // TODO: state.set.removeItem\r\n    // TODO: state.set.editItem\r\n    state.set.splice = (...args) => action([...args], \"splice\")\r\n    state.set.remove = (start, deleteCount = 1) => {\r\n        const returnValue = state.value.splice(start, deleteCount)\r\n        return state.set([...state.value], { methode: \"set\", action: \"remove\", args: [start, deleteCount], returnValue })\r\n    }\r\n    state.set.edit = (index, value) => {\r\n        isArray()\r\n        index = getIndex(index)\r\n        if (index > -1) {\r\n            if (value instanceof Function) {\r\n                value = value(state.value[index], index, state.value)\r\n            }\r\n            const returnValue = state.value.splice(index, 1, value)\r\n            return state.set([...state.value], { methode: \"set\", action: \"edit\", args: [index, value], returnValue })\r\n        }\r\n    }\r\n    state.set.push = (...items) => action([...items], \"push\")\r\n    state.set.pop = () => action([], \"pop\")\r\n    state.set.shift = () => action([], \"shift\")\r\n    state.set.unshift = (...items) => action([...items], \"shift\")\r\n    state.set.reverse = () => action([], \"reverse\")\r\n    state.set.fill = (...items) => action([...items], \"fill\")\r\n    state.set.filter = (predicate, ...args) => {\r\n        isArray()\r\n        isFunction(predicate)\r\n        const returnValue = state.value.filter(predicate, ...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"filter\", args: [predicate, ...args], returnValue })\r\n    }\r\n    state.set.slice = (...args) => {\r\n        isArray()\r\n        const returnValue = state.value.slice(...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"slice\", args, returnValue })\r\n    }\r\n    state.set.sort = (compareFn = (a, b) => b - a) => {\r\n        isArray()\r\n        isFunction(compareFn)\r\n        const oldValue = state.value.slice()\r\n        const returnValue = state.value.sort(compareFn)\r\n        if (returnValue.every((item, index) => item === oldValue[index])) return state.value\r\n        return state.set(returnValue, { methode: \"set\", action: \"sort\", args:arguments, returnValue })\r\n    }\r\n    state.set.map = (callbackfn, thisArg = state.value) => {\r\n        isArray()\r\n        isFunction(callbackfn)\r\n        const returnValue = state.value.map(callbackfn, ...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"map\", args, returnValue })\r\n    }\r\n}\r\n\r\nexport default function useState(value, guard = guardFn) {\r\n    if (value instanceof RXState) {\r\n        value = value\r\n        if (guard instanceof Function && guard !== guardFn) value.addGuard(guard);\r\n    } else if (Array.isArray(value) && value[0] instanceof RXState && value[1] === value[0].set) {\r\n        value = value[0]\r\n        if (guard instanceof Function && guard !== guardFn) value.addGuard(guard);\r\n    } else {\r\n        value = createState(value, guard)\r\n    }\r\n    return [value, value.set]\r\n}\r\n\r\n\r\nObject.entries(stateType).map(([type, guard]) => useState[type] = (value) => useState(value, guard))\r\nuseState.isState = isState","import useState from \"./useState.js\"\r\nconst refSymbol=Symbol(\"$$ref\")\r\nexport default function useRef(value) {\r\n    const [ref, changeRef] = useState(value)\r\n    const OBJECT=Object\r\n    return OBJECT.freeze(new (class {\r\n        constructor(){\r\n            OBJECT.defineProperty(this,\"current\",{\r\n                get:(()=>ref.value).bind(),\r\n                set:((val)=>changeRef(val)).bind(),\r\n                enumerable:true,\r\n                configurable:false\r\n            })\r\n            OBJECT.defineProperty(this,\"onChange\",{\r\n                value:((fn)=>ref.onChange(fn)).bind(),\r\n                enumerable:true,\r\n            })\r\n        }\r\n        onCleanup(fn){return ref.onCleanup(fn)}\r\n        destroy(fn){return ref.destroy(true)}\r\n        set(fn){return changeRef(fn)}\r\n        get [\".rxType\"](){return refSymbol}\r\n    }))\r\n}\r\nuseRef.isRef=((ref)=>(typeof ref==\"object\")&&refSymbol===ref[\".rxType\"]).bind()\r\n","import { RXState } from \"./useState.js\"\r\n\r\n// salu\r\n\r\nexport function useEffect(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    let remove\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> Promise.resolve().then(() => remove = callback([...array.map(getValue)],i))\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    requestIdleCallback(() => remove = callback([...array.map(getValue)],-1))\r\n    return () => {\r\n        listRmv.splice(0,listRmv.length).map(fn => fn?.())\r\n        if (remove instanceof Function) remove(-1, [...array].map(getValue))\r\n    }\r\n}","import { RXState } from \"./useState.js\"\r\n\r\nexport function useLayoutEffect(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    let remove\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> remove = callback([...array.map(getValue)],i)\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    update(-1)\r\n    return () => {\r\n        listRmv.splice(0,listRmv.length).map(fn => fn?.())\r\n        if (remove instanceof Function) remove(-1, [...array].map(getValue))\r\n    }\r\n}","import useState from \"./useState.js\";\r\n\r\nexport function useProps(props = {}) {\r\n    if(typeof props !=\"object\") throw new Error(\"props doit être une object\")\r\n    return {\r\n        ...Object.entries(props).reduce((prop, [key, value]) => ({ ...prop, [key]: (key === \"children\" || key.startsWith(\"$\"))? value :useState.isState(value) ?value : useState(value)[0] }), {})\r\n    }\r\n}","const handlerEvent = {\r\n    beforeDispatch: (...args) => [...args],\r\n    afterDispatch: (data, returnValue) => [data, returnValue],\r\n    onSubscribe: callback => callback,\r\n    clearAfterEachDispatch:false\r\n}\r\nexport function useEvent(handler = handlerEvent) {\r\n    if (typeof handler !== \"object\") throw new Error(\"handler doit être un object\")\r\n    const { beforeDispatch=handlerEvent.beforeDispatch, afterDispatch=handlerEvent.afterDispatch, onSubscribe=handlerEvent.onSubscribe,clearAfterEachDispatch=handlerEvent.clearAfterEachDispatch} = handler\r\n    const EVENTS = new Set()\r\n    const subscribe = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit être un function\")\r\n        callback = onSubscribe(callback)\r\n        if (callback instanceof Function) EVENTS.add(callback)\r\n        return () => EVENTS.delete(callback)\r\n    }\r\n    return [subscribe, (data,...rest) => {\r\n        const args = beforeDispatch(data,...rest)\r\n        const returnValue = EVENTS.forEach(fn => fn?.(...(Array.isArray(args)?args:[args])))\r\n        if(clearAfterEachDispatch)EVENTS.clear();\r\n        return afterDispatch(data, returnValue)\r\n    }]\r\n}","import useState, { RXState } from \"./useState.js\"\r\n\r\nexport function useMemo(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    const [state,setState]=useState()\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> setState(callback([...array.map(getValue)],i))\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    update(-1)\r\n    state.onCleanup(()=>listRmv.splice(0,listRmv.length).map(fn => fn?.()))\r\n    return state\r\n}","import { useEvent } from \"../hooks/useEvent.js\";\r\nimport { RXState } from \"../hooks/useState.js\";\r\nconst DATABASE = new WeakMap();\r\nexport function $(dom) {\r\n  if (!(dom instanceof Node))\r\n    throw new Error(\"dom doit etre un instance de Node\");\r\n  if (DATABASE.get(dom)) return DATABASE.get(dom);\r\n  let isDestroyed = false;\r\n  let destroyList = [];\r\n  const [onReady, dispatchReady] = useEvent({ clearAfterEachDispatch: true });\r\n  const [onConnected, dispatchConnected] = useEvent({clearAfterEachDispatch: true});\r\n  let isReady = false;\r\n  onReady(() => (isReady = true));\r\n  const children = [...dom.childNodes];\r\n  const textRef = new Text();\r\n  const root = new Text();\r\n  const fiber = null;\r\n  const getTextRoot = () =>\r\n    Promise.resolve().then(() => {\r\n      if (dom.parentNode) {\r\n        dom.after(textRef);\r\n        dom.after(root);\r\n      } else if (root.parentNode) {\r\n        root.after(textRef);\r\n      }\r\n      return textRef;\r\n    });\r\n  const isValid = () => {\r\n    if (isDestroyed)\r\n      throw new Error(\r\n        \"cette dom est deja considerer comme detruit, donc vous ne peux plus faire cette action...\"\r\n      );\r\n    return true;\r\n  };\r\n  function onCleanup(callback) {\r\n    isValid();\r\n    if (callback instanceof RXState && callback.value instanceof Function) {\r\n      const state = callback;\r\n      callback = (...args) => {\r\n        if (!(state.value instanceof Function))\r\n          throw new Error(\"state.value doit etre une function\");\r\n        state.value(...args);\r\n      };\r\n    } else if (Array.isArray(callback)) {\r\n      callback.map((fn) => handler.onDestroy(fn));\r\n      return;\r\n    }\r\n    if (callback instanceof Function) {\r\n      destroyList.push(callback);\r\n    }\r\n  }\r\n  const attr = (attrName, value) => {\r\n    if (!(dom instanceof Element)) return null;\r\n    if (attrName && value !== undefined) {\r\n      dom.setAttribute(attrName, value || \"\");\r\n      return dom.getAttribute(attrName);\r\n    } else if (attrName) {\r\n      return dom.getAttribute(attrName);\r\n    }\r\n    return dom.attributes;\r\n  };\r\n  const style = (propertyName, value) => {\r\n    if(dom instanceof Element){\r\n      if(value===undefined){\r\n        return dom.style[propertyName]\r\n      }\r\n      dom.style[propertyName]=value\r\n    }\r\n    return dom.style[propertyName]\r\n  };\r\n  const addClass = (className) => dom instanceof Element&&dom.classList.add(className);\r\n  const hasClass = (className) => dom instanceof Element&&dom.classList.contains(className);\r\n  const removeClass = (className) => dom instanceof Element&&dom.classList.remove(className);\r\n  const toggleClass = (className) => dom instanceof Element&&dom.classList.toggle(className);\r\n  const on = (type, value) => {\r\n    const handler=e=>value instanceof Function&&value(e)\r\n    dom.addEventListener(type,handler)\r\n    return ()=>dom.removeEventListener(type,handler)\r\n  };\r\n  const getFiber = () => fiber;\r\n\r\n  const destroy = (withDom = false) => { \r\n    if (dom instanceof Node && !(dom instanceof DocumentFragment)) {\r\n      dom.remove();\r\n    }\r\n    if (isDestroyed) return;\r\n    destroyList.map((fn) => fn instanceof Function && fn(withDom));\r\n    isDestroyed = true;\r\n    destroyList = [];\r\n    if (dom instanceof Text && withDom) {\r\n      dom.data = \"\";\r\n    }\r\n    // handler.$children.map((el) => el instanceof Node && $(el).destroy());\r\n  };\r\n  const HANDLER = {\r\n    getFiber: () => fiber,\r\n    attr,style,addClass,hasClass,removeClass,toggleClass,on,getFiber,\r\n    onConnected,dispatchConnected,onReady,dispatchReady,getTextRoot,\r\n    destroy,onCleanup,\r\n    isReady: () => isReady,\r\n    isDestroyed: () => isDestroyed,\r\n    isConnected: () => isConnected,\r\n    isCleaned: () => isClean,\r\n    get textRef() {\r\n      return textRef;\r\n    },\r\n    id: 123,\r\n  };\r\n  Object.freeze(HANDLER)\r\n  HANDLER.onConnected(() => {\r\n    if (dom.parentNode) {\r\n      dom.after(root);\r\n    }\r\n  });\r\n  const id=setInterval(()=>{\r\n    if(dom.parentElement){\r\n      clearInterval(id)\r\n      dispatchConnected(dom.parentElement);\r\n    }\r\n  },10)\r\n  DATABASE.set(dom, HANDLER);\r\n  return HANDLER;\r\n}\r\nexport const Children={\r\n  flat(children){\r\n    if(Array.isArray(children)){\r\n      return children.flat(Infinity)\r\n    }\r\n    throw new Error(\"children must be an Array\")\r\n  },\r\n  slot(children,slotName){\r\n    if(Array.isArray(children)){\r\n      return children.filter(child=>{\r\n        console.log(child);\r\n        return child instanceof Element&&child.getAttribute(\"slot\")===slotName\r\n      })\r\n    }\r\n    throw new Error(\"children must be an Array\")\r\n  },\r\n  filterByAttr(children,attrName,attrValue){\r\n    if(Array.isArray(children)){\r\n      if(attrValue===undefined) return  children.filter(child=>child instanceof Element&&child.getAttribute(attrName))\r\n      return children.filter(child=>child instanceof Element&&child.getAttribute(attrName)===attrValue)\r\n    }\r\n    throw new Error(\"children must be an Array\")\r\n  }\r\n}\r\n","\r\nconst rxErrorConfig={\r\n    lang:\"en\",\r\n    usePrettyLog:false\r\n}\r\n\r\nconst codeLogError= {\r\n    \"fr\":{\r\n        0:data=>\"\",\r\n    },\r\n    \"en\":{\r\n\r\n    }\r\n}\r\nconst CODES=[]\r\nexport function rxError({code,lang={fr:(data)=>\"rxError\",en:(data)=>\"rxError\"}}) {\r\n    if(CODES.includes(code)) throw new Error(\"ce code is already used\")\r\n    if(typeof lang !=\"object\")throw new Error(\"lang must be an object\")\r\n    CODES.push(code)\r\n    Object.entries(lang).map(([name,value])=>{\r\n        codeLogError[name][code]=(data)=>{\r\n            if(!(value instanceof Function)) throw new Error(\"each value of lang must be a function\")\r\n            return value(data)\r\n        }\r\n    })\r\n}\r\nexport function getStack(){\r\n    let stackString=\"\"\r\n    try {\r\n        throw new Error()\r\n    } catch (error) {\r\n        const stacks=error.stack.split(/at\\s(.+)\\s*/).slice(2).filter(e=>e).map(at=>{\r\n            const nameOfFunction=at.slice(0,at.indexOf(\" \"))\r\n            const file=at.slice(at.lastIndexOf(\"/\")+1,-1).split(\":\")\r\n            return {\r\n                at,\r\n                nameOfFunction,\r\n                source:at.slice(at.indexOf(\" \")+1).slice(1,-1),\r\n                fileName:file[0],\r\n                row:file[1],\r\n                col:file[2],\r\n            }\r\n        })\r\n        stacks.at(-1).source=\"h\"+stacks.at(-1).source+error.stack.at(-1)\r\n        stacks.at(-1).nameOfFunction=stacks.at(-1).nameOfFunction+error.stack.at(-1)\r\n        stackString=stacks\r\n    }\r\n    return stackString\r\n}\r\nexport default function getLogError(code=0,data=null){\r\n    try {\r\n        return codeLogError[rxErrorConfig[\"lang\"]][code](data)\r\n    } catch (error) {\r\n        return codeLogError[rxErrorConfig[\"lang\"]][0](data)\r\n    }\r\n}\r\n\r\nrxError({\r\n    code:0,\r\n    lang:{\r\n        fr:(data)=>{\r\n            return `rxError:${data}`\r\n        },\r\n        en:(data)=>{\r\n            return `rxError:${data}`\r\n        }\r\n    }\r\n})","\r\nexport function createRegExp(...regs){\r\n    return regs.reduce((regFinal,reg)=>new RegExp(regFinal.source+reg.source))\r\n}\r\nfunction getRegSource(reg){\r\n    return typeof reg==\"string\"?reg:reg.source\r\n}\r\nexport function combineRegExp(...regs){\r\n    return regs.reduce((regFinal,reg)=>new RegExp(regFinal.source+getRegSource(reg)))\r\n}\r\nexport function combineAndSaveRegExp(...regs){\r\n    return new RegExp(`(${combineRegExp(...regs).source})`)\r\n}\r\nexport function combineAndNoSaveRegExp(...regs){\r\n    return new RegExp(`(?:${combineRegExp(...regs).source})`)\r\n}\r\nexport function createRegExpSaved(...regs){\r\n    return new RegExp(`(${createRegExp(...regs).source})`)\r\n}\r\nexport function createRegExpSplit(...regs){\r\n    return createRegExpSaved(regs.reduce((regFinal,reg)=>new RegExp(regFinal.source+\"|\"+reg.source)))\r\n}","import { createRegExpSplit } from \"./RgExp.js\"\r\n\r\nexport class TemplateRef extends Array {\r\n    static get regExp() { return /\\(_\\|-\\[RXRefs\\{index:\\d+,type:[\\w\\$]+\\}\\]-\\|_\\)/ }\r\n    static get regExpSaved() { return /\\(_\\|-\\[RXRefs\\{index:(?<index>\\d+),type:(?<type>[\\w\\$]+)\\}\\]-\\|_\\)/ }\r\n    static get regExpSavedG() { return /\\(_\\|-\\[RXRefs\\{index:(?<index>\\d+),type:(?<type>[\\w\\$]+)\\}\\]-\\|_\\)/g }\r\n    static {\r\n        this.split = function (chaine = \"\", includeResults = true) {\r\n            if (typeof chaine != \"string\") throw new Error(\"chaine doit etre une chaine de caractere\")\r\n            const reg = includeResults ? createRegExpSplit(this.regExp) : this.regExp\r\n            const result = chaine.split(reg).reduce((l, item) => {\r\n                if (!item) return l\r\n                const r = this.parse(item)\r\n                if (r && includeResults instanceof Function) item = includeResults(r)\r\n                l.push(item)\r\n                return l\r\n            }, [])\r\n            return result\r\n        }\r\n        this.replaceAll = function (chaine, value = \"\") {\r\n            if (typeof chaine != \"string\") throw new Error(\"chaine doit etre une chaine de caractere\")\r\n            return chaine.replaceAll(this.regExpSavedG, (input, index, type) => value instanceof Function ? value({ input, index, type }) : value)\r\n        }\r\n        this.parse = function (chaine = \"\", refs = null) {\r\n            if (typeof chaine != \"string\") throw new Error(\"chaine doit etre une chaine de caractere\")\r\n            const result = /\\(_\\|-\\[RXRefs\\{index:(?<index>\\d+),type:(?<type>[\\w\\$]+)\\}\\]-\\|_\\)/.exec(chaine)\r\n            const value = refs ? this.split(chaine, ({ index }) => refs[index]) : null\r\n            const valueString = value ? value.join('') : \"\"\r\n            return result ? {\r\n                index: result.groups.index,\r\n                type: result.groups.type,\r\n                input: result.input,\r\n                value, valueString, refs\r\n            } : null\r\n        }\r\n    }\r\n    constructor(...refs) {\r\n        super()\r\n        this.push(...refs)\r\n        this.components={}\r\n    }\r\n}","import { useState, RXState, useLayoutEffect, useMemo, useRef } from \"../../hooks/indexHooks.js\"\r\nimport { $ } from \"../domController.js\"\r\nimport { TemplateRef } from \"../templateRef.js\"\r\n\r\nconst customeElementRegistry = {}\r\n\r\nconst regExpDirective = /^(?<directiveName>(?:[A-z][\\w\\-]*:)|@|#)(?<arg>[\\w-]*)(?<modifiers>\\[[\\w\\-,]*\\])?$/\r\nconst directiveOption = {\r\n    el: null,\r\n    attrName: \"\",\r\n    attrValue: \"\",\r\n    directiveName: \"\",\r\n    arg: \"\",\r\n    modifiers: {},\r\n    index: 0\r\n}\r\nexport class FiberOfNode {\r\n    #components = ({ ...customeElementRegistry })\r\n    get components() { return this.#components }\r\n    set components(components) {\r\n        Object.assign(this.#components, components)\r\n    }\r\n    refs = new TemplateRef()\r\n    directives = {\r\n        $onInit({ attrValue, el} = directiveOption){\r\n            attrValue=attrValue instanceof RXState?attrValue.value:attrValue\r\n            if(attrValue instanceof Function){\r\n                $(el).onCleanup=attrValue(el)\r\n                return\r\n            }\r\n            console.warn(\"$onInit.attrValue doit être de type Function\")\r\n        },\r\n        $shadowRoot({ attrValue, el, arg } = directiveOption) {\r\n            const elementsCanAttachShadowRoot = [\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]\r\n            if (elementsCanAttachShadowRoot.includes(el.localName) || el.localName.includes(\"-\")) {\r\n                let callback\r\n                if (attrValue instanceof RXState) attrValue = attrValue.value\r\n                if (attrValue instanceof Function) callback = attrValue\r\n                const oldChildren = [...el.childNodes]\r\n                const root = el.attachShadow({ mode: arg === \"closed\" ? \"closed\" : \"open\" })\r\n                const returnValue = callback instanceof Function ? callback({ el, root, children: oldChildren }) : oldChildren\r\n                const children = Array.isArray(returnValue) ? returnValue : [returnValue]\r\n                el.innerHTML = \"\"\r\n                root.append(...children)\r\n            } else {\r\n                console.warn(`l'element ${el.localName} ne suporte pas le attachShadow. Seule les element personnalisé (balise avec un tiré) et quelque element native le supporte,\r\n                voici une liste d'element qui le support:`, elementsCanAttachShadowRoot);\r\n            }\r\n        },\r\n        $attrState({ attrValue, el, setAttribute } = directiveOption) {\r\n            let cleanup\r\n            if (attrValue instanceof RXState) {\r\n                const update = (name, value) => {\r\n                    if (cleanup instanceof Function) cleanup();\r\n                    cleanup = setAttribute(el, name, value ?? \"\")\r\n                }\r\n                return attrValue.onChange((value, oldValue) => {\r\n                    if (value && typeof value == \"object\") {\r\n                        if (oldValue && typeof oldValue == \"object\") {\r\n                            const isAsOld = value.attrName === oldValue.attrName && value.attrValue === oldValue.attrValue\r\n                            if (!isAsOld) {\r\n                                update(value.attrName, value.attrValue ?? \"\")\r\n                            }\r\n                        } else {\r\n                            update(value.attrName, value.attrValue ?? \"\")\r\n                        }\r\n                    } else {\r\n                        update(value, \"\")\r\n                    }\r\n                    return cleanup\r\n                }, true)\r\n            }\r\n            return setAttribute(el, attrValue, true)\r\n        },\r\n        $if({ attrValue, el, index, data ,arg} = directiveOption) {\r\n            index = Math.random()\r\n            if (typeof data.listCondition != \"object\") data.listCondition = {}\r\n            const getValue = (value) => value instanceof Function ? value(el) : !!value\r\n            const hasValidNow=()=>Object.values(data.listCondition).every(isTrue => isTrue)\r\n            // const makeVisible = (isVisible = hasValidNow()) => el.getTextRoot()\r\n            const makeVisible = (isVisible = hasValidNow()) =>$(el).getTextRoot()\r\n                .then(textRef => {\r\n                    if(!textRef.parentNode){\r\n                        // return el.onConnected(()=>el.getTextRoot().then(()=>hasValidNow() ? textRef.after(el) : el.remove()))\r\n                        return $(el).onConnected(()=>$(el).getTextRoot().then(()=>hasValidNow() ? textRef.after(el) : el.remove()))\r\n                    }\r\n                    return textRef.parentNode && isVisible ? textRef.after(el) : el.remove()\r\n                })\r\n            if (attrValue instanceof RXState) {\r\n                return attrValue.onChange((value) => {\r\n                    const v=getValue(value)\r\n                    data.listCondition[index] =arg==\"false\"?!v:v\r\n                    makeVisible()\r\n                    return () => {\r\n                        delete data.listCondition[index]\r\n                        attrValue.destroy(true)\r\n                    }\r\n                }, true)\r\n            } else {\r\n                data.listCondition[index] = getValue(attrValue)\r\n                makeVisible()\r\n            }\r\n            return () => data.listCondition[index] = true\r\n        },\r\n        $ref({ el, attrValue } = directiveOption) {\r\n            if (attrValue instanceof RXState) {\r\n                attrValue=attrValue.value\r\n            }\r\n            if (attrValue instanceof Function) {\r\n                return attrValue(el)\r\n            }else if (useRef.isRef(attrValue)){\r\n                attrValue.current=el\r\n            }\r\n        },\r\n        $show({ el: dom, attrValue } = directiveOption) {\r\n            if (attrValue instanceof RXState) {\r\n                return attrValue.onChange((isShow) => {\r\n                    dom.hidden = !isShow\r\n                    return () => attrValue.destroy(true)\r\n                }, true)\r\n            } else {\r\n                dom.hidden = !attrValue\r\n            }\r\n        },\r\n        $bind({ el, arg, modifiers, attrValue } = directiveOption) {\r\n            const fnRmvs = []\r\n            if (attrValue instanceof RXState) {\r\n                fnRmvs.push(attrValue.onChange((v) => {\r\n                    if (arg in el) {\r\n                        el[arg] = v\r\n                    } else {\r\n                        el.setAttribute(arg, v)\r\n                    }\r\n                    return () => attrValue.destroy(true)\r\n                }, true))\r\n            }\r\n            const handlerEvent = () => {\r\n                const value = arg in el ? el[arg] : el.getAttribute(arg)\r\n                if (attrValue instanceof RXState) attrValue.set(value)\r\n            }\r\n            fnRmvs.push(...Object.keys(modifiers).map(eventName => {\r\n                el.addEventListener(eventName, handlerEvent)\r\n                return () => el.removeEventListener(eventName, handlerEvent)\r\n            }))\r\n            if (Object.keys(modifiers).length == 0) {\r\n                const eventName = [\"input\"].includes(el.localName) ? \"input\" : \"change\"\r\n                el.addEventListener(eventName, handlerEvent)\r\n                fnRmvs.push(() => el.removeEventListener(eventName, handlerEvent))\r\n            }\r\n            return () => fnRmvs.map(fn => fn())\r\n        },\r\n        $directives({ el, arg, modifiers, attrValue } = directiveOption) {\r\n            if (attrValue instanceof RXState) attrValue = attrValue.value\r\n            if (typeof attrValue == \"object\") {\r\n                Object.assign(this, attrValue)\r\n            }\r\n        }\r\n    }\r\n    initProps(refs = this.refs) {\r\n        if (!(refs instanceof TemplateRef)) throw new Error(\"refs must be an instance of RXRefs\")\r\n        const getrefs = ({ index }) => this.refs[index]\r\n        const generateKey = (data, key) => {\r\n            const gk = () => {\r\n                let i = Math.round(Math.random() * 100_000_000)\r\n                while ((key + `<${i}>`) in data) { i++ }\r\n                key += `<${i}>`\r\n                return key\r\n            }\r\n            if (key in data) {\r\n                if (key.includes(\"<\") && key.includes(\">\") && key.at(-1) == \">\") {\r\n                    const indexA = key.indexOf(\"<\")\r\n                    key = key.slice(0, indexA)\r\n                }\r\n                return gk()\r\n            }\r\n            return key\r\n        }\r\n        this.props = Object.entries(this.props).reduce((props, [attrName, value]) => {\r\n            const originalAttrName = attrName\r\n            const attrNameComputed = TemplateRef.parse(attrName, this.refs)\r\n            const valueArray = typeof value == \"string\" ? TemplateRef.split(value ?? \"\", getrefs) : [value]\r\n\r\n\r\n            if (/^\\s*$/.test(valueArray[0]) && !(valueArray[0] instanceof RXState)) valueArray.shift()\r\n            if (/^\\s*$/.test(valueArray.at(-1)) && !(valueArray[0] instanceof RXState)) valueArray.pop()\r\n\r\n            let hasValueFinal = false\r\n            let valueFinal\r\n            const getValue = () => {\r\n                if (hasValueFinal) return valueFinal\r\n                hasValueFinal = true\r\n                if (valueArray.length == 0) {\r\n                    valueFinal = \"\"\r\n                    return \"\"\r\n                }\r\n                if (valueArray.length == 1) {\r\n                    valueFinal = valueArray[0]\r\n                    return valueArray[0]\r\n                }\r\n                const stateValue = useMemo(() => valueArray.join(\"\") , valueArray)\r\n                valueFinal = stateValue\r\n                return stateValue\r\n            }\r\n            if (attrNameComputed) {\r\n                let hasCallback = false\r\n                const hasState = !!attrNameComputed.value.find(v => {\r\n                    if (v instanceof Function) {\r\n                        hasCallback = true\r\n                    }\r\n                    return v instanceof RXState\r\n                })\r\n                const isDirective = attrNameComputed.value[0] == \"$\" && attrNameComputed.value[1] instanceof Function\r\n                const createMemo = () => useMemo(() => ({\r\n                    attrName: attrNameComputed.value.map(v => v instanceof Function ? v.name : v instanceof RXState ? v.toString() : typeof v == \"object\" ? v?.constructor?.name : v).join(\"\"),\r\n                    attrValue: getValue()\r\n                }), [...attrNameComputed.value])\r\n\r\n                if (isDirective) {\r\n                    const callback = attrNameComputed.value[1]\r\n                    const id = Math.round(Math.random() * 1_000_000)\r\n                    const callbackName = (callback.name[0] == \"$\" ? callback.name : \"$\" + callback.name) + \"{\" + id + \"}\"\r\n                    this.directives[callbackName] = callback\r\n                    let key = \"$attrState\"\r\n                    key = generateKey(props, key)\r\n                    attrNameComputed.value[0] = \"\"\r\n                    attrNameComputed.value[1] = callbackName\r\n                    const attr = createMemo()\r\n                    props[key] = attr\r\n                    return props\r\n                } else if (hasState) {\r\n                    let key = \"$attrState\"\r\n                    key = generateKey(props, key)\r\n                    const attr = createMemo()\r\n                    props[key] = attr\r\n                    return props\r\n                } else if (hasCallback) {\r\n                    const lnc = [...attrNameComputed.value] // list Name Computed\r\n                    if (lnc[0] instanceof Function && lnc.length == 1) {\r\n                        let key = \"$onInit\"\r\n                        key = generateKey(props, key)\r\n                        props[key] = lnc[0]\r\n                        return props\r\n                    } else {\r\n                        let key = [...attrNameComputed.value].map(v => v instanceof Function ? v.name : v).join(\"\")\r\n                        key = generateKey(props, key)\r\n                        props[key] = getValue()\r\n                        return props\r\n                    }\r\n                } else if (attrNameComputed.value[0] instanceof Object && attrNameComputed.value.length === 1) {\r\n                    if (value != \"\") return props\r\n                    if (attrNameComputed.value[0].constructor !== Object) return props\r\n                    Object.entries(attrNameComputed.value[0]).map(([k, v]) => {\r\n                        k = generateKey(props, k)\r\n                        props[k] = v\r\n                    })\r\n                    return props\r\n                } else {\r\n                    attrName = attrNameComputed.valueString\r\n                }\r\n            }\r\n            let ismustState=false\r\n            if(attrName[0]==\":\"){\r\n                ismustState=true\r\n                attrName=attrName.slice(1)\r\n            }\r\n            if (attrName == \"children\") {\r\n                props.children = value\r\n                return props\r\n            }\r\n            attrName = generateKey(props, attrName)\r\n            props[attrName] = ismustState?useMemo(()=>getValue()):getValue()\r\n            return props\r\n        }, {})\r\n    }\r\n    constructor() {}\r\n    type\r\n    props\r\n    #dom\r\n    #parent\r\n    get parent(){return this.#parent}\r\n    set parent(parentFiber){\r\n        if(!(parentFiber instanceof FiberOfNode)) throw new Error('parentFiber doit être une instance FiberOfNode')\r\n        this.#parent=parentFiber\r\n    }\r\n    get dom(){\r\n        return this.#dom\r\n    }\r\n    set dom(domValue){\r\n        if(this.#dom) throw new Error(\"dom a déja une valeur Node \")\r\n        if(!(domValue instanceof Node)) throw new Error(\"domValue doit être une instance de Node\")\r\n        this.#dom=domValue\r\n    }\r\n}\r\nexport { customeElementRegistry }","import {TemplateRef} from \"../templateRef.js\"\r\nimport {FiberOfNode} from \"./FiberOfNode.js\"\r\n\r\nexport class FiberOfElement extends FiberOfNode {\r\n    constructor(type, props = {}, refs=new TemplateRef()) {\r\n        if (!(refs instanceof TemplateRef)) throw new Error(\"refs must be an instance of RXRefs\")\r\n        super()\r\n        this.type = type\r\n        this.refs = refs\r\n        this.props = Object.freeze({\r\n            ...props,\r\n            children: props.children?? []\r\n        })\r\n        this.props.children.map((child,index)=>{\r\n            if(child instanceof DocumentFragment){\r\n                this.props.children[index]=[...child.$children]\r\n            }\r\n        })\r\n        this.initProps(this.refs)\r\n        this.components=this.refs.components\r\n        if(this.components[type]){\r\n            this.type=this.components[type]\r\n        }\r\n        Object.freeze(this)\r\n    }\r\n}","import { TemplateRef } from \"../templateRef.js\"\r\nimport {FiberOfNode} from \"./FiberOfNode.js\"\r\n\r\nexport class FiberOfFragment extends FiberOfNode {\r\n    constructor(children, refs=new TemplateRef()) {\r\n        if (!(refs instanceof TemplateRef)) throw new Error(\"refs must be an instance of RXRefs\")\r\n        super()\r\n        this.refs = refs\r\n        this.type = \"FRAGMENT\"\r\n        this.props = Object.freeze({\r\n            children:children ?? []\r\n        })\r\n        this.initProps(this.refs)\r\n        Object.freeze(this)\r\n    }\r\n}","import { TemplateRef } from \"../templateRef.js\"\r\nimport {FiberOfNode} from \"./FiberOfNode.js\"\r\n\r\nexport class FiberOfText extends FiberOfNode {\r\n    constructor(text, refs=new TemplateRef()) {\r\n        if (!(refs instanceof TemplateRef)) throw new Error(\"refs must be an instance of RXRefs\")\r\n        super()\r\n        this.refs = refs\r\n        this.type = \"TEXT\"\r\n        this.props = Object.freeze({\r\n            nodeValue: text,\r\n            children: []\r\n        })\r\n        Object.freeze(this)\r\n        if(this.props.nodeValue instanceof Node ) {\r\n            if(this.props.nodeValue instanceof DocumentFragment){\r\n                console.log([...this.props.nodeValue.$children]);\r\n            }\r\n            return this.props.nodeValue\r\n        }\r\n        if (this.props.nodeValue instanceof FiberOfNode) return this.props.nodeValue\r\n    }\r\n}","import { useEvent, RXState } from \"../hooks/indexHooks.js\"\r\nimport { $ } from \"./domController.js\"\r\nimport { getStack } from \"./rxError.js\"\r\n\r\nimport { FiberOfElement, FiberOfFragment, FiberOfNode, FiberOfText } from \"./RxFiber/indexOfFiber.js\"\r\nimport { TemplateRef } from \"./templateRef.js\"\r\n\r\nconst needCallback = (callback, args, $this) => callback.apply($this, args)\r\nneedCallback.after = (callback, args, $this) => Promise.resolve().then(() => callback.apply($this, args))\r\nneedCallback.idle = (callback, args, $this) => requestIdleCallback(() => callback.apply($this, args))\r\n\r\nfunction createElement(fiber) {\r\n    const sendListOfDom = (list) => list.flat(Infinity).map(child => createDom(child))\r\n    if (fiber instanceof Node) return fiber\r\n    if (fiber instanceof FiberOfNode && fiber.dom instanceof Node) return fiber.dom\r\n    if (fiber instanceof FiberOfFragment) {\r\n        return sendListOfDom(fiber.props.children)\r\n    }\r\n    if (fiber instanceof FiberOfText) {\r\n        if (Array.isArray(fiber.props.nodeValue)) {\r\n            return sendListOfDom(fiber.props.nodeValue)\r\n        }\r\n        return fiber.props.nodeValue instanceof Node ? fiber.props.nodeValue : new Text(fiber.props.nodeValue)\r\n    }\r\n    if (fiber instanceof FiberOfElement) {\r\n        if (fiber.components[fiber.type] instanceof Function) {\r\n            const component = fiber.components[fiber.type]\r\n            fiber.type = component\r\n        }\r\n        if (fiber.type instanceof Function) {\r\n            let props = fiber.props\r\n            if (typeof fiber.type.defaultProps == \"object\") props = { ...fiber.type.defaultProps, ...props }\r\n            const el = fiber.type(props)\r\n            return createDom(el)\r\n        }\r\n        return document.createElement(fiber.type)\r\n    }\r\n    if (Array.isArray(fiber)) {\r\n        return sendListOfDom(fiber)\r\n    }\r\n    if (fiber instanceof Function) {\r\n        let props = { children: [] }\r\n        if (typeof fiber.defaultProps == \"object\") props = { ...fiber.defaultProps, children: [] }\r\n        return createDom(fiber(props))\r\n    }\r\n    if (fiber instanceof RXState) {\r\n        return createDom(new FiberOfText(fiber, new TemplateRef()))\r\n    }\r\n    try {\r\n        return new Text(JSON.stringify(fiber))\r\n    } catch (error) {\r\n        return new Text(fiber)\r\n    }\r\n}\r\nfunction initProps(dom, fiber) {\r\n    if (!(dom instanceof Node)) throw new Error('dom doit etre un element node')\r\n    if (!(dom instanceof HTMLElement)) return null\r\n    if (fiber && fiber.type instanceof Function) return null;\r\n    if (!(fiber instanceof FiberOfElement)) return null\r\n    const globalData = {}\r\n    const counterName = {}\r\n    \r\n    const setOneAttribute = (props, [attrName, attrValue], dom, listOnCleanup = []) => {\r\n        const setAttribute = (value, domEl = dom, attrN = attrName) => {\r\n            if (/^\\s*$/.test(attrN)) return\r\n            if (domEl instanceof HTMLSelectElement && [\"multiple\",].includes(attrN)) {\r\n                domEl.multiple = true\r\n            } else\r\n                if ([\"disabled\", \"hidden\"].includes(attrN)) {\r\n                    // console.log(value);\r\n                    // domEl.setAttribute(attrN,\"\")\r\n                    return domEl[attrN] = value === \"\" ? true : value\r\n                } else if ((attrN in domEl) || ([\"object\", \"function\"].includes(typeof value))) {\r\n                    if (typeof value == \"object\" && typeof domEl[attrN] == \"object\") return Object.assign(domEl[attrN], value)\r\n                    return domEl[attrN] = value\r\n                }\r\n            domEl.setAttribute(attrN, value)\r\n        }\r\n        const setAttr = (el, attrName, attrValue) => {\r\n            const listrmv = []\r\n            setOneAttribute(props, [attrName, attrValue], el, listrmv)\r\n            return () => needCallback(() => listrmv.map(fn => fn instanceof Function && fn()/** */))\r\n        }\r\n        const rendAttribute = (update, onRemove) => {\r\n            const redOneStyle = (value) => {\r\n                if (value instanceof RXState) {\r\n                    // dom.onCleanup = value.onChange((val, oldVal) => {\r\n                    $(dom).onCleanup(value.onChange((val, oldVal) => {\r\n                        update(val, oldVal)\r\n                        return () => value.destroy()\r\n                    }, true))\r\n                } else {\r\n                    update(value)\r\n                }\r\n            }\r\n            if (Array.isArray(attrValue)) {\r\n                attrValue.map(val => redOneStyle(val))\r\n            } else {\r\n                redOneStyle(attrValue)\r\n            }\r\n            $(dom).onCleanup(() => onRemove instanceof Function && onRemove())\r\n        }\r\n        const toClean = () => null\r\n        let cleanup = toClean\r\n        let resultReg\r\n        const rcState = attrValue\r\n        const originalAttrName = attrName\r\n        const res = /^([^<>]+)<\\d+>$/.exec(attrName)\r\n        if (res) { attrName = res[1] }\r\n        if (attrName == \"children\" || !(fiber instanceof FiberOfElement)) return props\r\n        if (typeof attrName != \"string\") return props\r\n\r\n        if (attrName && (attrName.startsWith('on') || attrName.startsWith('@'))) {\r\n\r\n            let type = attrName.slice(attrName.startsWith('on') ? 2 : 1).toLowerCase()\r\n            if (type.indexOf(\"<\") > -1) {\r\n                type = type.slice(0, type.indexOf(\"<\"))\r\n            }\r\n            const applyCallback = (fn, args = []) => {\r\n                if (fn instanceof RXState) {\r\n                    fn = fn.isDestroyed ? () => null : fn.value\r\n                }\r\n                return fn(...args)\r\n            }\r\n            const callback = (...args) => {\r\n                if (Array.isArray(attrValue)) {\r\n                    return attrValue.map(fn => applyCallback(fn, args))\r\n                }\r\n                applyCallback(attrValue, args)\r\n            }\r\n            let removeEv = () => dom.removeEventListener(type, callback)\r\n            $(dom).onCleanup(removeEv)\r\n            // dom.onDestroy(removeEv)\r\n            dom.addEventListener(type, callback)\r\n            cleanup = () => removeEv\r\n            return props\r\n        } else if (attrName[0] == \".\") {\r\n            const oldValue = dom[attrName.slice(1)]\r\n            dom[attrName.slice(1)] = attrValue\r\n            cleanup = () => dom[attrName.slice(1)] = oldValue\r\n            return props\r\n        } else if (resultReg = /^(?<name>(?:\\$|\\:)[^\\s</>\\:\\[\\]]+)(?:\\:(?<arg>[^\\s</>:\\[\\]]*)(\\[(?<modifiers>[^\\s</>\\[\\]]*)\\])?)?(?:\\<(?<index>\\d+)\\>)?$/.exec(attrName)) {\r\n            const { name, arg, modifiers } = resultReg.groups\r\n            counterName[name] = name in counterName ? counterName[name] + 1 : 0\r\n            if (fiber.directives[name] instanceof Function) {\r\n                let index = counterName[name]\r\n                const directivesMustSync = [\"$ref\"]\r\n                const callback = directivesMustSync.includes(name) ? needCallback : needCallback.after\r\n                callback(() => {\r\n                    if (!globalData[name]) globalData[name] = {}\r\n                    const rmv = fiber.directives[name]({\r\n                        setAttribute: setAttr,\r\n                        globalData,\r\n                        data: globalData[name],\r\n                        el: dom, attrName, attrValue,\r\n                        index: index ? Number(index) : 0,\r\n                        directiveName: name, arg,\r\n                        modifiers: modifiers?.split(',').reduce((data, modif) => { data[modif] = true; return data }, {}) || {}\r\n                    })\r\n                    if (rmv instanceof Function) {\r\n                        // dom.onDestroy(rmv)\r\n                        $(dom).onCleanup(rmv)\r\n                        cleanup = rmv\r\n                        listOnCleanup.push(cleanup)\r\n                    }\r\n                })\r\n            }\r\n            return props\r\n        } else if ([\"input\", \"select\", \"textarea\"].includes(dom.localName) && [\"value\", \"checked\"].includes(attrName) && (rcState instanceof RXState)) {\r\n            if ([\"select\"].includes(dom.localName) && dom instanceof HTMLSelectElement) {\r\n                dom.value = rcState.value\r\n                // dom.onReady(()=>{\r\n                $(dom).onReady(() => {\r\n                    dom.selectedIndex = -1\r\n                    let i = -1\r\n                    for (let opt of dom) {\r\n                        i++\r\n                        if (opt.value === rcState.value) {\r\n                            dom.selectedIndex = i\r\n                        }\r\n                    }\r\n                })\r\n                // dom.selectedIndex=2\r\n            }\r\n            const rmv = (e) => needCallback.after(() => {\r\n\r\n                if ([\"checkbox\"].includes(e.target.type)) {\r\n                    return rcState.set(e.target.checked)\r\n                }\r\n                return rcState.set(e.target[attrName])\r\n            })\r\n            dom.addEventListener('input', rmv)\r\n            cleanup = () => {\r\n                dom.removeEventListener(\"input\", rmv)\r\n                dom.value = \"\"\r\n            }\r\n            // dom.onDestroy(cleanup)\r\n            $(dom).onCleanup(cleanup)\r\n        } else if (attrName == \"style\" || /^style<\\d+>/.test(attrName)) {\r\n            const styleDefault = dom.style.cssText\r\n            const rendStyle = (value) => needCallback.after(() => {\r\n                if (value instanceof Object) {\r\n                    Object.assign(dom.style, value)\r\n                } else {\r\n                    dom.style.cssText += value\r\n                }\r\n            })\r\n            rendAttribute(rendStyle, () => rendStyle(styleDefault))\r\n            return props\r\n        } else if (attrName == \"class\" || /^class\\<\\d+\\>/.test(attrName)) {\r\n            const styleDefault = dom.getAttribute(\"class\")\r\n\r\n            const rendClass = (value, oldValue) => needCallback.after(() => {\r\n                const addValue = (_value) => String(_value).split(\" \").map(val => val && dom.classList.add(val))\r\n                const removeValue = (_value) => String(_value).split(\" \").map(val => val && dom.classList.remove(val))\r\n                Array.isArray(oldValue) ? oldValue.map(val => removeValue(val)) : removeValue(oldValue);\r\n                Array.isArray(value) ? value.map(val => addValue(val)) : addValue(value)\r\n            })\r\n            rendAttribute(rendClass, () => rendClass(styleDefault))\r\n            return props\r\n        } else if (attrName && attrName.startsWith('?')) {\r\n            attrName = /^([^<>]+)\\<\\d+\\>/.test(attrName) ? attrName.slice(0, attrName.indexOf(\"<\")) : attrName\r\n            if (!attrValue) return props\r\n            let rmvAttr//=setAttr(dom,attrName.slice(1),\"\")\r\n            const insertAttr = (value) => {\r\n                const inertAttr = (v) => setAttr(dom, attrName.slice(1), v)\r\n                if (typeof attrValue == \"object\") {\r\n                    const { when, value: val } = value\r\n                    if (when instanceof RXState) {\r\n                        let rmAt\r\n                        return when.onChange((isTrue) => {\r\n                            if (isTrue) {\r\n                                if (!rmAt) rmAt = inertAttr(val instanceof RXState ? val.get() : val)\r\n                            } else {\r\n                                if (rmAt) rmAt();\r\n                                rmAt = null\r\n                            }\r\n                            return () => rmAt && rmAt();\r\n                        }, true)\r\n                    } else {\r\n\r\n                        if (when) return inertAttr(val)\r\n                    }\r\n                } else {\r\n                    return inertAttr(value)\r\n                }\r\n            }\r\n            if (attrValue instanceof RXState) {\r\n\r\n            } else {\r\n                rmvAttr = insertAttr(attrValue)\r\n            }\r\n\r\n            const rmv = () => rmvAttr()\r\n            if (rmv instanceof Function) {\r\n                dom.onDestroy(rmv)\r\n                cleanup = rmv\r\n                listOnCleanup.push(cleanup)\r\n            }\r\n            return props\r\n        }\r\n        if (attrValue instanceof RXState) {\r\n            const state = attrValue\r\n            const clean = state.onChange(v => {\r\n                setAttribute(v)\r\n                return () => {\r\n                    state.destroy(true)\r\n                    dom.removeAttribute(attrName)\r\n                }\r\n            })\r\n            // dom.onDestroy(clean)\r\n            $(dom).onCleanup(clean)\r\n            attrValue = attrValue.value\r\n            listOnCleanup.push(clean)\r\n        }\r\n\r\n        setAttribute(attrValue)\r\n        if (cleanup === toClean) {\r\n            cleanup = () => {\r\n                dom.removeAttribute(attrName)\r\n            }\r\n        }\r\n        listOnCleanup.push(cleanup)\r\n        return props\r\n    }\r\n    Object.entries(fiber.props).reduce((props, [attrName, attrValue]) => setOneAttribute(props, [attrName, attrValue], dom), {})\r\n}\r\nconst updateArray = {\r\n    set(valueOfState, oldValueOfState, { methode, value, textRef, listElement }) {\r\n        if (!Array.isArray(listElement)) throw new Error(\"listElement doit être une Array\")\r\n        if (!Array.isArray(valueOfState)) throw new Error(\"valueOfState doit être une Array\")\r\n        textRef.$firstElement = listElement[0]\r\n        if (valueOfState.every(v => v instanceof Node)) {\r\n            const listDom = []\r\n            listElement.splice(0, listElement.length, ...valueOfState.map((item, indexItem) => {\r\n                const dom = createDom(item)\r\n                if (indexItem == 0) {\r\n                    if (textRef.$firstElement !== dom) {\r\n                        textRef.$firstElement = dom\r\n                        textRef.after(dom)\r\n                    }\r\n                } else if (listElement[indexItem] !== dom) {\r\n                    listDom.at(-1).after(dom)\r\n                } else { }\r\n                listDom.push(dom)\r\n                return dom\r\n            })).map(e => !listElement.find(_e => _e === e) && $(e).destroy(true))\r\n        } else {\r\n            listElement.splice(0, listElement.length, ...valueOfState.map(v => {\r\n                const dom = createDom(v)\r\n                textRef.before(dom)\r\n                return dom\r\n            })).map(e => $(e).destroy())\r\n        }\r\n    }\r\n}\r\nfunction updateDataBinding(state, textDom, dom, listElement) {\r\n    const remove = state.onChange((valueOfState, oldValueOfState, { methode, value, ...option }) => {\r\n        oldValueOfState instanceof Node && valueOfState !== oldValueOfState && oldValueOfState.destroy(true)\r\n\r\n        if (valueOfState instanceof Node) {\r\n            listElement.splice(0, listElement.length).map(el => el instanceof Node && el.destroy())\r\n            textDom.data = \"\"\r\n            needCallback.idle(() => textDom.after(valueOfState))\r\n            listElement.push(valueOfState)\r\n        } else {\r\n            textDom.data = valueOfState\r\n            if (Array.isArray(valueOfState)) {\r\n                textDom.data = \"\"\r\n                const args = [valueOfState, oldValueOfState, { ...option, methode, value, listElement, textRef: textDom }]\r\n                needCallback.after(() => {\r\n                    if (updateArray[methode] instanceof Function) {\r\n                        updateArray[methode](...args)\r\n                    } else {\r\n                        updateArray.set(...args)\r\n                    }\r\n                })\r\n            } else if (valueOfState instanceof FiberOfNode) {\r\n                textDom.data = \"\"\r\n                let isUpdate = true\r\n                // console.log(isUpdate);\r\n                listElement.splice(0, listElement.length).map(el => el instanceof Node && el.destroy())\r\n                isUpdate = false\r\n                const el = createDom(valueOfState)\r\n                listElement.push(el)\r\n                el.onDestroy(() => listElement.length && remove())\r\n                let isRended = false\r\n                const putAfter = (elRef, elTarget, isforced = false) => {\r\n                    if (isRended && !isforced) return true\r\n                    if (elRef.parentNode) {\r\n                        elRef.after(elTarget)\r\n                        isRended = true\r\n                        return true\r\n                    }\r\n                    return false\r\n                }\r\n\r\n                const rendLater = () => {\r\n                    putAfter(textDom, el)\r\n                    if (!isRended) return requestIdleCallback(rendLater)\r\n                }\r\n                requestIdleCallback(rendLater)\r\n                textDom.onConnected((p) => {\r\n                    if (p instanceof Node && textDom.parentNode !== p) {\r\n                        p.append(textDom)\r\n                        return putAfter(textDom, el, true)\r\n                    }\r\n                    putAfter(textDom, el)\r\n                })\r\n            } else if (typeof valueOfState == \"object\") {\r\n                try {\r\n                    textDom.data = JSON.stringify(valueOfState, null, 20)\r\n                } catch (error) { }\r\n            }\r\n        }\r\n        return (withDom = true) => {\r\n            textDom.data = \"\"\r\n            listElement.map(dom => dom.destroy(withDom))\r\n            if (oldValueOfState instanceof Node) {\r\n                oldValueOfState.destroy()\r\n            }\r\n            if (withDom) {\r\n                textDom.remove()\r\n                state.destroy(true)\r\n            }\r\n        }\r\n    }, true)\r\n    // dom.onDestroy(remove)\r\n    $(dom).onCleanup(remove)\r\n}\r\nfunction bindData(textDom, textFiber) {\r\n    if (!(textFiber.props.nodeValue instanceof RXState)) return textDom\r\n    let state = textFiber.props.nodeValue\r\n    const dom = Array.isArray(state.value) ? new DocumentFragment() : textDom\r\n    textFiber.dom = dom\r\n    // insertEventDom(dom)\r\n    if (Array.isArray(state.value)) dom.append(textDom)\r\n\r\n    if (!(textDom instanceof Text)) throw new Error(\"textDom doit être une instance de Text\")\r\n    // if (!(textDom.onDestroy instanceof Function)) throw new Error(\"textDom.onDestroy doit être une fonction\")\r\n\r\n    let listElement = []\r\n    // updateDataBinding(state, textDom, dom, listElement)\r\n    needCallback.after(() => updateDataBinding(state, textDom, dom, listElement))\r\n\r\n    return dom\r\n}\r\nfunction insertEventDom(dom) {\r\n    console.warn(123);\r\n    throw new Error(\"the function insertEventDom is deprecied..., Please use insertEventDom.$(dom)\")\r\n    if (!(dom instanceof Node)) throw new Error(\"dom doit etre un instance de Node\")\r\n    if (dom.destroy instanceof Function) return;\r\n    useEvent\r\n    let isDestroyed = false\r\n    let destroyList = []\r\n    const [onReady, dispatchReady] = useEvent({ clearAfterEachDispatch: true })\r\n    const [onConnected, dispatchConnected] = useEvent({ clearAfterEachDispatch: true })\r\n    let isReady = false\r\n    onReady(() => isReady = true)\r\n    const $children = [...dom.childNodes]\r\n    const textRef = new Text()\r\n    const root = new Text()\r\n    const getTextRoot = () => Promise.resolve().then(() => {\r\n        if (dom.parentNode) {\r\n            dom.after(textRef)\r\n            dom.after(root)\r\n        } else if (root.parentNode) {\r\n            root.after(textRef)\r\n        }\r\n        return textRef\r\n    })\r\n    Object.defineProperties(dom, {\r\n        \"onConnected\": {\r\n            get: () => onConnected,\r\n            set: val => onConnected(val)\r\n        },\r\n        \"onReady\": {\r\n            get: () => onReady,\r\n            set: val => onReady(val)\r\n        },\r\n        \"isReady\": {\r\n            get: () => isReady,\r\n        },\r\n        \"dispatchReady\": {\r\n            get: () => dispatchReady,\r\n        },\r\n        \"dispatchConnected\": {\r\n            get: () => dispatchConnected\r\n        },\r\n        \"model\": {},\r\n        isDestroyed: {\r\n            get() { return isDestroyed }\r\n        },\r\n        isClean: {\r\n            get() { return isDestroyed }\r\n        },\r\n        \"destroyList\": { get() { return [...destroyList] } },\r\n        \"onDestroy\": {\r\n            value: (callback) => {\r\n                if (callback instanceof RXState && callback.value instanceof Function) {\r\n                    const state = callback\r\n                    callback = (...args) => {\r\n                        if (!(state.value instanceof Function)) throw new Error(\"state.value doit etre une function\")\r\n                        state.value(...args)\r\n                    }\r\n                } else if (Array.isArray(callback)) {\r\n                    callback.map(fn => dom.onDestroy(fn))\r\n                    return\r\n                }\r\n                if ((callback instanceof Function)) {\r\n                    destroyList.push(callback)\r\n                }\r\n            },\r\n            writable: false\r\n        },\r\n        \"destroy\": {\r\n            value: (withDom = false) => {\r\n                if (dom instanceof Node && !(dom instanceof DocumentFragment)) {\r\n                    dom.remove()\r\n                }\r\n                if (isDestroyed) return\r\n                dom.destroyList.map(fn => fn(withDom))\r\n                isDestroyed = true\r\n                destroyList = []\r\n                if (dom instanceof Text && withDom) {\r\n                    dom.data = \"\"\r\n                }\r\n                dom.$children.map(el => el instanceof Node && el.destroy())\r\n            },\r\n            writable: false\r\n        },\r\n        \"onCleanup\": {\r\n            get() { return dom.onDestroy },\r\n            set(value) { dom.onDestroy(value) }\r\n        },\r\n        \"$children\": {\r\n            get() { return $children },\r\n            set(value) {\r\n                value = Array.isArray(value) ? value : [value]\r\n                $children.push(...value)\r\n            }\r\n        },\r\n        getTextRoot: {\r\n            value: getTextRoot,\r\n            writable: false\r\n        },\r\n        textRef: {\r\n            get() { return textRef }\r\n        }\r\n\r\n    })\r\n    dom.onConnected(() => {\r\n        if (dom.parentNode) {\r\n            dom.after(root)\r\n        }\r\n    })\r\n}\r\n\r\nconst listOfTagPriority = [\"style\", \"link\"]\r\nconst isRendPriority = (element, container) => {\r\n    if (listOfTagPriority.includes(String(element?.type).toLowerCase())) return true\r\n    if (listOfTagPriority.includes(container.localName)) return true\r\n}\r\nfunction createTextRef(container) {\r\n    if (!(container instanceof Node)) throw new Error(\"container doit être de type Node\")\r\n    const txtRef = new Text(\"\")\r\n    if (container.shadowRoot) {\r\n        container.shadowRoot.append(txtRef)\r\n    } else {\r\n        container.append(txtRef)\r\n    }\r\n    return txtRef\r\n}\r\nexport function render(element, container = document.body) {\r\n    if (typeof container == \"string\") container = document.querySelector(container)\r\n    if (!(container instanceof Node)) throw new Error(\"container doit être de type Node\")\r\n    let returnDom\r\n    const txtRef = createTextRef(container)\r\n    function appendChild(dom) {\r\n        if (Array.isArray(dom)) {\r\n            returnDom = dom.map(child => render(child, container))\r\n            return returnDom\r\n        }\r\n        // insertEventDom(dom)\r\n        // insertEventDom(container)\r\n        $(container).onCleanup($(dom).onCleanup)\r\n        // container.onDestroy(dom.destroy)\r\n        const append = () => {\r\n            txtRef.after(dom)\r\n            // if (container instanceof DocumentFragment) container.$children = dom;\r\n            // $(container).$children = dom\r\n            $(dom).dispatchConnected(container)\r\n            // dom.dispatchConnected(container)\r\n        }\r\n        append()\r\n        txtRef.remove()\r\n        returnDom = dom\r\n    }\r\n    async function init() {\r\n        if (returnDom) return returnDom\r\n        if (!(container instanceof Node)) throw new Error(\"container doit etre un instance de Node\")\r\n        const dom = await needCallback.after(() => createDom(element))\r\n        appendChild(dom)\r\n        return returnDom\r\n    }\r\n    if (isRendPriority(element, container)) {\r\n        const dom = createDom(element)\r\n        appendChild(dom)\r\n    }\r\n    return init()\r\n}\r\n\r\nexport function createDom(fiber) {\r\n    if (fiber instanceof FiberOfNode && fiber.dom instanceof Node) {\r\n        throw new Error(\"fibre a déja une instance dom, fais une copie du fibre si vous voulez une autre instance\")\r\n    }\r\n    if (Array.isArray(fiber)) {\r\n        // fiber=new FiberOfFragment(fiber)\r\n        return fiber.flat(Infinity).map(child => createDom(child))\r\n    } else if (fiber instanceof Function) {\r\n        fiber = new FiberOfElement(fiber, { children: [] })\r\n    } else if (!(fiber instanceof EventTarget) && !(fiber instanceof FiberOfNode)) {\r\n        fiber = new FiberOfText(fiber)\r\n    }\r\n    const dom = createElement(fiber)\r\n    if (fiber instanceof FiberOfNode && dom instanceof Node && !(dom.fiber instanceof FiberOfNode)) {\r\n        Object.defineProperty(dom, \"fiber\", {\r\n            get: () => fiber\r\n        })\r\n    }\r\n\r\n    const createChild = (childDom) => {\r\n        // insertEventDom(childDom)\r\n        // const handlerDom=$(childDom)\r\n        if (fiber instanceof Node) return childDom\r\n        if (fiber instanceof FiberOfText && RXState.isState(fiber.props.nodeValue)) return bindData(childDom, fiber)\r\n        if (fiber && fiber.type instanceof Function) return childDom\r\n        const rending = []\r\n        if (fiber instanceof FiberOfNode) {\r\n            fiber.dom = childDom\r\n            if (!fiber.props.children) return childDom\r\n            rending.push(...fiber.props.children.flat(Infinity).map(child => {\r\n                if (typeof fiber.components != \"object\") {\r\n                    console.warn(\"fiber.component doit être une object\");\r\n                    fiber.components = {}\r\n                }\r\n                if (child instanceof FiberOfNode) {\r\n                    child.parent = fiber\r\n                    Object.assign(child.directives, fiber.directives)\r\n                    child.components = fiber.components\r\n                }\r\n                return render(child, childDom)\r\n            }))\r\n        }\r\n        Promise.all(rending)\r\n            .then((children) => {\r\n                initProps(childDom, fiber)\r\n                needCallback.after(() => $(childDom).dispatchReady(childDom, children))\r\n            })\r\n        return childDom\r\n    }\r\n    if (Array.isArray(dom)) {\r\n        if (fiber.parent instanceof FiberOfNode) {\r\n            return dom\r\n        }\r\n        const doc = new DocumentFragment\r\n        // insertEventDom(doc)\r\n        // $(doc).$children = dom\r\n        // doc.$children = dom\r\n        doc.append(...dom)\r\n        return doc\r\n    }\r\n    return createChild(dom)\r\n}","import { useProps } from \"../hooks/indexHooks.js\"\r\n\r\nexport function component(callback, option = { defaultProps: {}}) {\r\n    if(typeof option!=\"object\") throw new Error(\"option doit être une de type object\")\r\n    const defaultProps=option.defaultProps??{}\r\n    if(typeof defaultProps!=\"object\") throw new Error(\"option.defaultProps doit être une de type object\")\r\n    const fn=(props) => callback(useProps({...defaultProps,...props}))\r\n    fn.defaultProps=defaultProps\r\n    return fn\r\n}\r\n","import { useEvent, useProps, useState } from \"../hooks/indexHooks.js\"\r\nimport { createDom } from \"./core.js\"\r\nimport { $ } from \"./domController.js\"\r\nconst REGISTER = new WeakMap();\r\nconst options={\r\n  defaultProps:{},\r\n  shadowRoot:null\r\n}\r\nexport function define(tagName, renderCallback, option = options) {\r\n    const { defaultProps = options.defaultProps, shadowRoot = options.shadowRoot } =\r\n      option;\r\n    const CLASSElement = class extends HTMLElement {\r\n      static get observedAttributes() {\r\n        return Object.keys(defaultProps);\r\n      }\r\n      attributeChangedCallback(name, oldV, newV) {\r\n        const props = REGISTER.get(this).props;\r\n        if (\r\n          useState.isState(props[name]) &&\r\n          props[name].toString() != newV &&\r\n          typeof props[name].value != \"object\"\r\n        ) {\r\n          props[name].set(newV);\r\n          console.log(name, newV);\r\n        }\r\n      }\r\n      constructor(_props) {\r\n        super();\r\n        _props = typeof _props == \"object\" && _props ? _props : {};\r\n        const handler={\r\n          connectedCallback: useEvent(),\r\n          disconnectedCallback: useEvent(),\r\n          adoptedCallback: useEvent(),\r\n          onCleanup: [() => {}],\r\n          mounted: useEvent({\r\n            onSubscribe: (fn) => {\r\n              return (...arg) => {\r\n                const rv = fn(arg);\r\n                if (rv instanceof Function) {\r\n                  this.onCleanup(rv);\r\n                }\r\n              };\r\n            },\r\n          }),\r\n          props: _props,\r\n          children: []\r\n        }\r\n        REGISTER.set(this, handler);\r\n        $(this)\r\n        if(Array.isArray(_props.children)){\r\n          handler.children.push(..._props.children)\r\n        }\r\n        const root = option.shadowRoot\r\n          ? this.attachShadow({\r\n              mode: \"closed\" === option.shadowRoot?.mode ? \"closed\" : \"open\",\r\n              delegatesFocus: !!option.shadowRoot?.delegatesFocus,\r\n              slotAssignment:\r\n                \"manual\" === option.shadowRoot?.slotAssignment\r\n                  ? \"manual\"\r\n                  : \"named\",\r\n            })\r\n          : this;\r\n          $(root)\r\n        const $component = Object.freeze({\r\n          root,\r\n          el: this,\r\n          ...Object.entries(handler).reduce((ob, [k, v]) => {\r\n            if (Array.isArray(v)) {\r\n              ob[k] = v[0];\r\n            }\r\n            return ob;\r\n          }, {}),\r\n        });\r\n        setTimeout(() => {\r\n          Promise.resolve().then(() => {\r\n            for (let i of this.attributes) {\r\n                const name=i.name\r\n              if(useState.isState(_props[name])){\r\n                  _props[name].set(i.value)\r\n              }else{\r\n                  _props[name]=i.value\r\n              }\r\n            }\r\n            handler.props = useProps({ ...defaultProps, ..._props });\r\n            handler.children.push(...this.childNodes);\r\n            const el = renderCallback(\r\n              { ...handler.props, children:[...handler.children] },\r\n              $component\r\n            );\r\n            //   this.innerHTML = \"\";\r\n            root.append(createDom(el));\r\n            handler.mounted[1](this);\r\n            if (this.isConnected) {\r\n              handler.connectedCallback[1]();\r\n            }\r\n          });\r\n        });\r\n      }\r\n      connectedCallback() {\r\n        REGISTER.get(this).connectedCallback[1]();\r\n      }\r\n      disconnectedCallback() {\r\n        REGISTER.get(this).disconnectedCallback[1]();\r\n      }\r\n      adoptedCallback() {\r\n        REGISTER.get(this).adoptedCallback[1]();\r\n      }\r\n    };\r\n  \r\n    customElements.define(tagName, CLASSElement, {});\r\n    return (props) => new CLASSElement({ children: [], ...props });\r\n  }","\r\nimport { TemplateRef } from \"../templateRef.js\"\r\nimport { combineAndNoSaveRegExp, createRegExpSplit, combineAndSaveRegExp } from \"../RgExp.js\"\r\n\r\nexport const listTagEmpty = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"]\r\nexport const listTagKnown = [\"a\", \"abbr\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"bdi\", \"bdo\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"img\", \"input\", \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"meta\", \"meter\", \"nav\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"slot\", \"small\", \"source\", \"span\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"]\r\n\r\n//a mettre dans RgExp une fois stable\r\nexport const regExpHtmlTag = /<(?:\\/\\s*)?(?:[^\\!<>\\s\"'=\\/\\\\]+)\\s*(?:(?:\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*\"[^\"]*\"|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*'[^']*'|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*[^<>\\s\"'=\\/\\\\]+|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+?)*)\\s*(?:\\/)?\\s*>/g\r\nexport const regExpHtmlTagSave = /(<(?:\\/\\s*)?(?:[^\\!<>\\s\"'=\\/\\\\]+)\\s*(?:(?:\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*\"[^\"]*\"|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*'[^']*'|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*[^<>\\s\"'=\\/\\\\]+|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+?)*)\\s*(?:\\/)?\\s*>)/\r\nexport const regExpHtmlTagFullCapture = /<(?<isClosingTag>\\/\\s*)?(?<type>[^\\!<>\\s\"'=\\/\\\\]+)\\s*(?<attr>(?:\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*\"[^\"]*\"|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*'[^']*'|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+\\s*=\\s*[^<>\\s\"'=\\/\\\\]+|\\s*(?<=\"|'|\\s)[^<>\\s\"'=\\/\\\\]+?)*)\\s*(?<isAutoClose>\\/)?\\s*>/\r\nexport const regStringValidHtml = /[^<>\\s\"'`=\\/\\\\]+/\r\nexport const regStringValidHtmlSaved = /^(?<attrName>[^<>\\s\"'`=\\/\\\\]+)$/\r\nexport const regAttributeName = /(?<=\"|'|`|\\s*)[^<>\\s\"'`=\\/\\\\]+\\s*/\r\n\r\n// export const regAttrWithQuotes=/(?:\\s*(?<=\"|'|`|\\s)[^<>\\s\"'`=\\/\\\\]+\\s*=\\s*\"[^\"]*\")/\r\nexport const regAttrWithQuotesSaved = /^(?<attrName>[^<>\\s\"'`=\\/\\\\]+)\\s*=\\s*\"(?<attrValue>[^\"]*)\"$/\r\nexport const regExpAttrWithQuotes = combineAndNoSaveRegExp(regAttributeName, /\\s*=\\s*/, /\"[^\"]*\"/)\r\n\r\n// export const regAttrWithApostrophe=/(?:\\s*(?<=\"|'|`|\\s)[^<>\\s\"'`=\\/\\\\]+\\s*=\\s*'[^']*')/\r\nexport const regAttrWithApostropheSaved = /^(?<attrName>[^<>\\s\"'`=\\/\\\\]+)\\s*=\\s*'(?<attrValue>[^']*)'$/\r\nexport const regExpAttrWithApostrophe = combineAndNoSaveRegExp(regAttributeName, /\\s*=\\s*/, /'[^']*'/)\r\n\r\nexport const regAttrWithBacktic = /(?:\\s*(?<=\"|'|`|\\s)[^<>\\s\"'`=\\/\\\\]+\\s*=\\s*`[^`]*`)/\r\nexport const regAttrWithBackticSaved = /^(?<attrName>[^<>\\s\"'`=\\/\\\\]+)\\s*=\\s*`(?<attrValue>[^`]*)`$/\r\nexport const regExpAttrWithBacktic = combineAndNoSaveRegExp(regAttributeName, /\\s*=\\s*/, /`[^`]*`/)\r\n\r\n// export const regAttrWithNoDelimiter=/(?:\\s*(?<=\"|'|`|\\s)[^<>\\s\"'`=\\/\\\\]+\\s*=\\s*[^<>\\s\"'`=\\/\\\\]+\\s*)/\r\nexport const regAttrWithNoDelimiterSaved = /^(?<attrName>[^<>\\s\"'`=\\/\\\\]+)\\s*=\\s*(?<attrValue>[^<>\\s\"'`=\\/\\\\]+)$/\r\nexport const regExpAttrWithNoDelimiter = combineAndNoSaveRegExp(regAttributeName, /\\s*=\\s*/, regStringValidHtml)\r\n\r\n\r\nexport const regExpAttr = createRegExpSplit(\r\n    regExpAttrWithQuotes,\r\n    regExpAttrWithApostrophe,\r\n    regExpAttrWithBacktic,\r\n    regExpAttrWithNoDelimiter,\r\n    /\\s+/\r\n)\r\n\r\nexport function fasteSplitHtmlString(htmlString) { //1\r\n    return htmlString.split(regExpHtmlTagSave)\r\n}\r\n\r\n\r\nexport function isOpenTag(htmlTag) { // 1\r\n    const result = regExpHtmlTagFullCapture.exec(htmlTag)\r\n    if (!result) return null\r\n    return result.groups.isClosingTag ? false : true\r\n}\r\nexport function isCloseTag(htmlTag) { //1\r\n    return !isOpenTag(htmlTag)\r\n}\r\nexport function getCloseTag(htmlTag) { //1\r\n    const result = regExpHtmlTagFullCapture.exec(htmlTag)\r\n    if (!result) return null\r\n    return isCloseTag(htmlTag) ? result.groups.type : null\r\n}\r\nexport function getOpenTag(htmlTag) { //1\r\n    const result = regExpHtmlTagFullCapture.exec(htmlTag)\r\n    if (!result) return null\r\n    return !result.groups.isClosingTag ? result.groups.type : null\r\n}\r\n\r\nexport function parseAttrString(attrString) { //1\r\n    let result\r\n    const counterName = {}\r\n    const value = (attr, name, value) => {\r\n        const directive = (val = value, names = name) => {\r\n            if (attr[names]) {\r\n                let i = Math.round(Math.random() * 100_000_000)\r\n                while ((names + `<${i}>`) in attr) { i++ }\r\n                attr[names + `<${i}>`] = val\r\n                return attr[names]\r\n            }\r\n            return val\r\n        }\r\n        if (name.startsWith(\"?\")||name.startsWith(\"on\")||[\"style\",\"class\"].includes(name)) {\r\n            return directive()\r\n        } else if (result = /^(?<name>\\$[^\\s</>:\\[\\]]+)(?:\\:(?<arg>[^\\s</>:\\[\\]]*)(\\[(?<modifiers>[^\\s</>\\[\\]]*)\\])?)?(?:\\<(?<index>\\d+)\\>)?$/.exec(name)) {\r\n            return directive()\r\n        }\r\n        return isNaN(value) ? value : Number(value)\r\n    }\r\n    return attrString.split(regExpAttr).reduce((attr, chaine) => {\r\n        if (/^\\s*$/.test(chaine)) return attr\r\n        let result\r\n        if (result = regAttrWithQuotesSaved.exec(chaine)) {\r\n            attr[result.groups.attrName] = value(attr, result.groups.attrName, result.groups.attrValue)\r\n        } else if (result = regAttrWithApostropheSaved.exec(chaine)) {\r\n            attr[result.groups.attrName] = value(attr, result.groups.attrName, result.groups.attrValue)\r\n        } else if (result = regAttrWithBackticSaved.exec(chaine)) {\r\n            attr[result.groups.attrName] = value(attr, result.groups.attrName, result.groups.attrValue)\r\n        } else if (result = regAttrWithNoDelimiterSaved.exec(chaine)) {\r\n            attr[result.groups.attrName] = value(attr, result.groups.attrName, result.groups.attrValue)\r\n        } else if (result = regStringValidHtmlSaved.exec(chaine)) {\r\n            attr[result.groups.attrName] = \"\"\r\n        }\r\n        return attr\r\n    }, {})\r\n}\r\nexport function parseHtmlTag(htmlTag) { //1\r\n    const result = regExpHtmlTagFullCapture.exec(htmlTag)\r\n    if (!result) return null\r\n    const { type, attr, isAutoClose, isClosingTag } = result.groups\r\n    return {\r\n        get isTagEmpty() {\r\n            return listTagEmpty.includes(this.type)\r\n        },\r\n        get isTagKnown() {\r\n            return listTagKnown.includes(this.type)\r\n        },\r\n        type,\r\n        attr,\r\n        isAutoClose,\r\n        isClosingTag,\r\n        htmlTag,\r\n        props: parseAttrString(result.groups.attr),\r\n        initType(rxRefs) {\r\n            if (!(rxRefs instanceof TemplateRef)) throw new Error(\"rxRefs must be instance of RXRefs\")\r\n            const parseResult = TemplateRef.parse(this.type, rxRefs)\r\n            if (parseResult && parseResult.value.length == 2 && parseResult.value[0].at(-1) == \":\" && parseResult.value[1] instanceof Function) {\r\n                this.type = parseResult.value[0].slice(0, -1)\r\n                rxRefs.components[this.type] = parseResult.value[1]\r\n                // this.type = rxRefs.components[this.type]\r\n                return this.type\r\n            }\r\n            let type = TemplateRef.split(this.type, (({ index }) => rxRefs[index]))\r\n            type = type.length === 1 ? type[0] : type.join(\"\")\r\n            if (typeof type != \"string\" && typeof type != \"function\") {\r\n                type = `${typeof type}.is-not-component-valid`\r\n            }\r\n            // const componentList = Object.keys(rxRefs.components ?? {})\r\n            // if (!isKnownElement(type) && componentList.includes(type)) {\r\n            //     type = rxRefs.components[type]\r\n            // }\r\n            return this.type = type\r\n        }\r\n    }\r\n}\r\nexport function isKnownElement(type) {\r\n    return listTagKnown.includes(type?.toLowerCase?.())\r\n}\r\nexport function isTagEmpty(type) {\r\n    return listTagEmpty.includes(type?.toLowerCase?.())\r\n}","import { FiberOfElement, FiberOfFragment, FiberOfNode, FiberOfText } from \"../RxFiber/indexOfFiber.js\"\r\nimport { TemplateRef } from \"../templateRef.js\"\r\nimport { createRegExpSplit } from \"../RgExp.js\"\r\nimport { fasteSplitHtmlString, isOpenTag, isTagEmpty, parseHtmlTag } from \"./HtmlStringParser.js\"\r\n\r\nfunction rxReform(fiberList, htmlStringSplited, dataBinding) {\r\n    while (htmlStringSplited.length) {\r\n        const text = htmlStringSplited.shift()\r\n        if (/^\\s*$/.test(text)) continue\r\n        if (isOpenTag(text)) {\r\n            const fiber = parseHtmlTag(text)\r\n            fiber.children = []\r\n            fiber.initType(dataBinding)\r\n            if (!isTagEmpty(fiber.type) && !fiber.isAutoClose) {\r\n                getChildren(fiber, htmlStringSplited, dataBinding)\r\n            }\r\n            const el = new FiberOfElement(fiber.type, { ...fiber.props, children: fiber.children }, dataBinding)\r\n            fiberList.push(el)\r\n        } else {\r\n            const listT = text.split(createRegExpSplit(TemplateRef.regExp, /{{[^{}]*}}/))//(/((?:\\(_\\|-\\[RXRefs\\{index:\\d+,type:\\w+\\}\\]-\\|_\\))|(?:{{[^{}]*}}))/)\r\n            if (/^\\s*$/.test(listT[0])) listT.shift()\r\n            if (/^\\s*$/.test(listT.at(-1))) listT.pop()\r\n            fiberList.push(...listT.map(t => {\r\n                const isRef = (typeof t == \"string\") ? TemplateRef.parse(t, dataBinding) : t\r\n                t = isRef ? isRef.value[0] : t\r\n                if (typeof t != \"string\") return t\r\n                const isComment = (c) => /\\s*\\<\\!--.*--\\>\\s*/.test(c)\r\n                if (isComment(t)) {\r\n                    return t.split(/(\\s*\\<\\!--.*--\\>\\s*)/).map(t =>isComment(t) ? document.createComment(/^\\s*\\<\\!--(.*)--\\>\\s*$/.exec(t)[1]): t).filter(t => t)\r\n                }\r\n                return new FiberOfText(t, dataBinding)\r\n            }))\r\n        }\r\n    }\r\n    return fiberList\r\n}\r\nfunction getChildren(fiber, htmlStringSplited, dataBinding) {\r\n    if (fiber.type instanceof Function && !fiber.type.name) return\r\n    let count = 1\r\n    const index = htmlStringSplited.findIndex(e => {\r\n        const tag = parseHtmlTag(e)\r\n        const rcRef = TemplateRef.parse(tag ? tag.type : e, dataBinding)\r\n        if (tag && ((rcRef && rcRef.value[0] === fiber.type) || (tag.type === fiber.type))) {\r\n            count = tag.isClosingTag ? count - 1 : count + 1\r\n            if (tag.isClosingTag && count <= 0) return true\r\n        }\r\n        return false\r\n    })\r\n    if (index === -1) {\r\n        fiber.children = htmlStringSplited.splice(0, htmlStringSplited.length).filter(e => !/^\\s*$/.test(e))\r\n    } else {\r\n        fiber.children = htmlStringSplited.splice(0, index + 1).filter(e => !/^\\s*$/.test(e))\r\n        fiber.children.pop()\r\n    }\r\n    if (fiber.type == \"script\") {\r\n        let innerText = fiber.children.join(\"\")\r\n        const res = TemplateRef.parse(innerText, dataBinding)\r\n        if (res) {\r\n            innerText = res.valueString\r\n        }\r\n        fiber.children = [new Text(innerText)]\r\n    } else {\r\n        fiber.children = rxReform([], fiber.children, dataBinding)\r\n    }\r\n}\r\nfunction parse(strings, ...rxRefs) {\r\n    return [[...rxRefs.reduce((list, _str, index) => {\r\n        list.push(strings[index], `(_|-[RXRefs{index:${index},type:${typeof rxRefs[index]}}]-|_)`)\r\n        return list\r\n    }, []), strings[rxRefs.length]].join(\"\"), rxRefs]\r\n}\r\n\r\nfunction parseHtmlString(htmlString, rxRefs) {\r\n    if (!(rxRefs instanceof TemplateRef)) throw new Error(\"rxRefs must be instance of RXRefs\")\r\n    const htmlArray = fasteSplitHtmlString(htmlString)\r\n    const html = rxReform([], htmlArray, rxRefs)\r\n    if (html.length == 1) {\r\n        const el = html[0]\r\n        return el instanceof FiberOfNode ? el : new FiberOfText(el, rxRefs)\r\n    }\r\n    const frag = new FiberOfFragment(html, rxRefs)\r\n    return frag\r\n}\r\n\r\nexport function template(strings, ...refs) {\r\n    let config\r\n    if (typeof refs[0] == \"object\" && refs[0][\"<isStore>\"] === true) {\r\n        config = refs[0]\r\n        refs[0] = \"\"\r\n    }\r\n    const [htmlstring] = parse(strings, ...refs)\r\n    const rxRefs = new TemplateRef(...refs)\r\n    const rcNode = parseHtmlString(htmlstring, rxRefs)\r\n    if (config) {\r\n        if (config.components && typeof config.components == \"object\") rcNode.components = config.components\r\n        if (config.directives && typeof config.directives == \"object\") rcNode.directives = config.directives\r\n    }\r\n    return rcNode\r\n}","export { createDom, render } from \"./core/core.js\";\r\nexport {component} from \"./core/component.js\";\r\nexport { useState, RXState,useRef,useEffect,useLayoutEffect,useProps,useEvent,useMemo } from \"./hooks/indexHooks.js\";\r\nexport {define} from \"./core/customeElement.js\";\r\nexport { TemplateRef as LinksOfDataInTemplateString } from \"./core/templateRef.js\";\r\nexport {FiberOfElement,FiberOfFragment,FiberOfNode,FiberOfText} from \"./core/RxFiber/indexOfFiber.js\";\r\nexport { template } from \"./core/RcHtmlString/RcHtmlString.js\";\r\n\r\nimport { createDom, } from \"./core/core.js\";\r\nimport { useState,RXState} from \"./hooks/indexHooks.js\";\r\nimport { template } from \"./core/RcHtmlString/RcHtmlString.js\";\r\n\r\n\r\nexport function html(...args) {\r\n    return createDom(template(...args))\r\n}\r\nconst needCallback = (callback, args, $this) => callback.apply($this, args)\r\nneedCallback.after = (callback, args, $this) => Promise.resolve().then(() => callback.apply($this, args))\r\nneedCallback.idle = (callback, args, $this) => requestIdleCallback(() => callback.apply($this, args))\r\n//###################\r\nconst Fragment = \"FRAGMENT\"\r\nconst TextElement = \"TEXT\"\r\nexport function createFiber(type, props, ...children) {\r\n    const refs = new LinksOfDataInTemplateString()\r\n    props = props ?? { children: [] }\r\n    children = children.map(child => child instanceof RcHtmlNode ? child : new RcHtmlText(child, refs))\r\n    if (type == Fragment) {\r\n        return new RcHtmlFragment(children, refs)\r\n    }\r\n    if (type == TextElement) {\r\n        return new RcHtmlText(children, refs)\r\n    }\r\n    return new RcHtmlElement(type, { ...props, children }, refs)\r\n}\r\ncreateFiber.Fragment = Fragment\r\ncreateFiber.Text = TextElement\r\n//###################\r\n\r\n\r\nfunction map(state, callback) {\r\n    const list=state instanceof RXState?[...(state.value)]:state\r\n    var [state,setState]=useState(state,(v)=>{\r\n        list.splice(0,list.length,...v)\r\n        return list\r\n    })\r\n    // isFunction(callback)\r\n    const createState = (v, i) => [useState(v)[0], useState(i)[0]]\r\n    const rendMap = (v) => callback(...v, state,(value)=>{\r\n        const [item,index]=v\r\n        return setState.edit(index,value)\r\n    })\r\n    const listState = state.value.map(createState)\r\n    let listElement = needCallback.after(()=>listState.map(rendMap))\r\n    const [items, setItems] = useState(listElement)\r\n    items.onChange(list=>needCallback.after(()=>{\r\n        if(list instanceof Promise) return;\r\n        if(!list.every(item=>item instanceof Node)){\r\n            throw new Error(\"html.map doit retourner des list d'element Node\")\r\n        }\r\n    }),true)\r\n    const update = () => listState.map(([v, i], index) => needCallback.after(()=>{\r\n        if (!i.isDestroyed) i.set(index);\r\n        if (!v.isDestroyed) v.set(state.value[index]);\r\n    }))\r\n    state.onChange((val) => {\r\n        if (listState.length > val.length) {\r\n            const indexStart = val.length\r\n            const end = listState.length\r\n            listState.splice(indexStart, end).map(s => s.map(i => i.destroy(true)))\r\n            setItems.splice(indexStart, end)\r\n        } else if (listState.length < val.length) {\r\n            const indexStart = listState.length\r\n            listState.push(...val.slice(indexStart).map(createState))\r\n            listState.map(([, index], i) => index.set(i))\r\n            setItems.push(...listState.slice(indexStart).map(rendMap))\r\n        }\r\n        update()\r\n        // console.log(items.value);\r\n    })\r\n    return items\r\n}\r\nhtml.map=map\r\n"],"names":["guardFn","v","stateSymbol","Symbol","isState","ref","bind","RXState","isArray","Array","this","value","toString","String","valueOf","static","createState","guard","currentValueOfState","oldValueOfState","isDestroyed","subscriber","ID","Math","random","GUARDS","DESTROY_EVENTS","Set","UPDATE_EVENTS","ACTIONS","Object","freeze","guards","id","len","onChange","size","onCleanup","addGuard","Function","callback","a","lastIndex","push","isRemoved","splice","i","find","fn","clear","withDom","forEach","destroy","callbackOrState","directApply","state","args","set","slice","Error","on","dispatch","undefined","methode","onDispatch","arg","isCalled","delete","add","oldValue","constructor","super","defineProperty","get","enumerable","assign","actions","toValidate","option","oldValues","reduceRight","val","Promise","createStateComputed","dependencies","optDependencies","update","optionState","setState","useState","listrmv","map","st","_1","_2","entries","stateType","type","fnGuard","then","_oldValue","dispatchUpdate","stateInstace","isFunction","getIndex","index","findIndex","isNaN","rendMap","listState","listElement","items","setItems","length","indexStart","end","s","action","returnValue","remove","start","deleteCount","edit","pop","shift","unshift","reverse","fill","filter","predicate","sort","compareFn","b","every","item","arguments","callbackfn","thisArg","insertArrayMethode","k","payload","array","number","string","function","boolean","symbol","object","refSymbol","useRef","changeRef","OBJECT","configurable","useEffect","states","listRmv","getValue","resolve","requestIdleCallback","useLayoutEffect","useProps","props","reduce","prop","key","startsWith","isRef","handlerEvent","beforeDispatch","afterDispatch","data","onSubscribe","clearAfterEachDispatch","useEvent","handler","EVENTS","rest","useMemo","DATABASE","WeakMap","$","dom","Node","destroyList","onReady","dispatchReady","onConnected","dispatchConnected","isReady","childNodes","textRef","Text","root","HANDLER","getFiber","attr","attrName","Element","setAttribute","getAttribute","attributes","style","propertyName","addClass","className","classList","hasClass","contains","removeClass","toggleClass","toggle","e","addEventListener","removeEventListener","getTextRoot","parentNode","after","DocumentFragment","isValid","onDestroy","isConnected","isCleaned","isClean","setInterval","parentElement","clearInterval","codeLogError","fr","en","CODES","combineAndNoSaveRegExp","regs","RegExp","regFinal","reg","source","getRegSource","combineRegExp","createRegExpSaved","createRegExp","createRegExpSplit","code","lang","includes","name","rxError","TemplateRef","regExp","regExpSaved","regExpSavedG","split","chaine","includeResults","l","r","parse","replaceAll","input","refs","result","exec","valueString","join","groups","components","customeElementRegistry","directiveOption","el","attrValue","directiveName","modifiers","FiberOfNode","directives","$onInit","console","warn","$shadowRoot","elementsCanAttachShadowRoot","localName","oldChildren","attachShadow","mode","children","innerHTML","append","$attrState","cleanup","$if","listCondition","hasValidNow","values","isTrue","makeVisible","isVisible","$ref","current","$show","isShow","hidden","$bind","fnRmvs","keys","eventName","$directives","initProps","getrefs","generateKey","at","indexA","indexOf","round","gk","attrNameComputed","valueArray","test","valueFinal","hasValueFinal","stateValue","hasCallback","hasState","createMemo","callbackName","lnc","ismustState","parent","parentFiber","domValue","FiberOfElement","child","$children","FiberOfFragment","FiberOfText","text","nodeValue","log","needCallback","$this","apply","idle","updateArray","valueOfState","$firstElement","listDom","indexItem","createDom","_e","before","bindData","textDom","textFiber","isRended","putAfter","elRef","elTarget","isforced","rendLater","p","JSON","stringify","error","updateDataBinding","listOfTagPriority","render","element","container","document","body","querySelector","returnDom","txtRef","shadowRoot","createTextRef","appendChild","toLowerCase","isRendPriority","async","init","fiber","flat","Infinity","EventTarget","sendListOfDom","list","component","defaultProps","createElement","doc","childDom","rending","all","HTMLElement","globalData","counterName","setOneAttribute","listOnCleanup","domEl","attrN","HTMLSelectElement","multiple","setAttr","rendAttribute","onRemove","redOneStyle","oldVal","toClean","resultReg","rcState","res","applyCallback","removeEv","rmv","Number","modif","selectedIndex","opt","target","checked","styleDefault","cssText","rendStyle","rendClass","addValue","_value","removeValue","rmvAttr","insertAttr","inertAttr","when","rmAt","clean","removeAttribute","createChild","REGISTER","options","define","tagName","renderCallback","CLASSElement","observedAttributes","attributeChangedCallback","oldV","newV","_props","connectedCallback","disconnectedCallback","adoptedCallback","mounted","rv","delegatesFocus","slotAssignment","$component","ob","setTimeout","customElements","listTagEmpty","listTagKnown","regExpHtmlTagSave","regExpHtmlTagFullCapture","regStringValidHtmlSaved","regAttributeName","regAttrWithQuotesSaved","regExpAttrWithQuotes","regAttrWithApostropheSaved","regExpAttrWithApostrophe","regAttrWithBackticSaved","regExpAttrWithBacktic","regAttrWithNoDelimiterSaved","regExpAttr","isOpenTag","htmlTag","isClosingTag","parseAttrString","attrString","directive","names","parseHtmlTag","isAutoClose","isTagEmpty","isTagKnown","initType","rxRefs","parseResult","rxReform","fiberList","htmlStringSplited","dataBinding","getChildren","listT","t","isComment","c","createComment","count","tag","rcRef","innerText","parseHtmlString","htmlString","htmlArray","fasteSplitHtmlString","html","template","strings","config","htmlstring","_str","rcNode","createFiber","LinksOfDataInTemplateString","RcHtmlNode","RcHtmlText","RcHtmlFragment","RcHtmlElement","Fragment"],"mappings":"AAAA,MAAMA,EAAUC,GAAKA,EACfC,EAAcC,OAAO,WACrBC,GAAYC,GAAuB,iBAAPA,GAAoBH,IAAgBG,EAAI,YAAYC,OAC/E,MAAMC,EACLC,cAAY,OAAOC,MAAMD,QAAQE,KAAKC,MAAQ,CAClDC,WAAa,OAAOC,OAAOH,KAAKC,MAAQ,CACxCG,UAAY,OAAOJ,KAAKC,KAAO,CAC1B,eAAe,OAAOT,CAAa,CACxCa,eAAiBX,EAErB,SAASY,EAAYL,EAAOM,GACxB,IAAIC,EACAC,EACAC,GAAc,EACdC,EAAW,EACf,MAAMC,EAAKC,KAAKC,SACVC,EAAS,GACTC,EAAiB,IAAIC,IACrBC,EAAgB,IAAID,IACpBE,EAAQ,CAAE,EAGhB,OAAOC,OAAOC,OAAO,kBAA2BxB,EACxCyB,aAAW,MAAO,IAAIP,EAAS,CAC/BL,kBAAgB,OAAOA,CAAa,CACpCa,SAAO,OAAOX,CAAI,CAClBY,UAAQ,MAAO,CAACC,SAASP,EAAcQ,KAAKC,UAAUX,EAAeU,KAAKf,aAAa,CAC3FiB,SAASrB,GACL,KAAMA,aAAiBsB,UAAW,MAAO,KACzC,QAAMC,EAAW,IAAIC,IAAMxB,KAASwB,GAC9BC,EAAYjB,EAAOkB,KAAKH,GAAY,EAC1C,IAAII,GAAY,EAChB,MAAO,KACH,GAAIA,EAAW,OAAO,EACtB,GAAInB,EAAOiB,KAAeF,EAGtB,OAFAf,EAAOoB,OAAOH,EAAW,GACzBE,GAAY,GACL,EAEX,MAAME,EAAIrB,EAAOsB,MAAKC,GAAMA,IAAOR,IACnC,OAAIM,GAAK,IACLrB,EAAOoB,OAAOC,EAAG,IACV,EAEJ,CAEd,CAEDG,MAAMC,GAAU,GACZxB,EAAeyB,SAAQH,GAAMA,EAAGE,KAChCxB,EAAeuB,QACfrB,EAAcqB,OACjB,CACDG,QAAQF,GAAU,GACV9B,IACJV,KAAKuC,MAAMC,GACX9B,GAAc,EACjB,CAEDe,UAAW,CAAEkB,EAAiBC,GAAc,KACxC,GAAID,aAA2B9C,EAAS,CACpC,MAAMiC,EAAWc,aAAuBf,SAAWe,EAAcrD,GAAKA,EAChEsD,EAAMF,EAEZ,IAAIT,EACJ,OAFAvB,IAEOX,KAAKyB,UAAS,IAAIqB,KACrBD,EAAME,KAAI,IAAMjB,KAAYgB,OAAUA,EAAKE,MAAM,IAC1C,KACAd,IACHA,GAAU,EACVvB,IAAY,KAEjB,EACN,CACD,KAAMgC,aAA2Bd,UAAW,MAAM,IAAIoB,MAAM,mCAC5D,MAAMC,EAAK,CACPC,SAAUR,EAAiBD,QAASE,EAAcD,EAAgB3C,KAAKC,WAAOmD,EAAW,CAAEC,QAAS,MAAOpD,MAAOD,KAAKC,aAAWmD,GAEhIE,EAAa,IAAIC,IAAQL,EAAGR,QAAUQ,EAAGC,YAAYI,GAC3D,IAAIC,GAAW,EACf,MAAMd,EAAU,IAAIa,KACZC,IACJA,GAAW,EACPN,EAAGR,mBAAmBb,UAAUqB,EAAGR,WAAWa,GAClDvC,EAAeyC,OAAOf,GACtBxB,EAAcuC,OAAOH,GAAW,EAIpC,OAFApC,EAAcwC,IAAIJ,GAClBtC,EAAe0C,IAAIhB,GACZA,CACV,GAAE9C,OACH+B,WAAcG,IACV,KAAMA,aAAoBD,UAAW,MAAM,IAAIoB,MAAM,mCAGrD,OADAjC,EAAe0C,KADN,IAAIZ,IAAOhB,KAAYgB,KAEzB,IAAM9B,EAAeyC,OAAO3B,EACtC,GAAElC,OAGC+D,eAAa,OAAOlD,CAAiB,CAEzCmD,YAAY3D,EAAOM,EAAQhB,IAAKA,IAW5B,GAVAsE,QACAzC,OAAO0C,eAAe9D,KAAM,QAAS,CACjC+D,KAAK,IAAOvD,GAAqBZ,OACjCmD,KAAO9C,GAAUD,KAAK+C,IAAI9C,IAAQL,OAClCoE,YAAY,IAEbzD,GAAuB,iBAARA,IACda,OAAO6C,OAAO9C,EAAQZ,EAAM2D,SAAS,CAAA,GACrC3D,EAAMA,EAAMA,OAAQ,CAAAhB,GAAKA,MAEvBgB,aAAiBsB,UAAW,MAAM,IAAIoB,MAAM,gCAClDzC,EAAsBP,EACtBc,EAAOkB,KAAK1B,GACZ,MAAM4D,EAAa,CAAClE,EAAO0D,EAAWlD,EAAiB2D,EAAS,MAC5D,MAAMC,EAAY,GAClB,OAAOtD,EAAOuD,aAAY,CAACC,EAAKjF,KAC5B+E,EAAUpC,KAAKsC,GACRjF,EAAQiF,EAAKZ,EAAUS,EAAQ,IAAIC,MAC3CpE,EAAK,EAENA,aAAiBuE,UACnBhE,EAAsB2D,EAAWlE,OAAOmD,EAAW,CAAA,IAEvD,MAAMqB,EAAsB,CAAC3C,EAAW,KAAMtB,GAAqBkE,EAAe,GAAInE,EAAQhB,IAAKA,MAC/F,KAAMuC,aAAoBD,UAAW,MAAM,IAAIoB,MAAM,mCACrD,GAAIvC,EAAa,MAAM,IAAIuC,MAAM,mEACjC,MAAM0B,EAAiBD,IAAe3E,MAAMD,QAAQ4E,IAAoC,iBAAdA,EAAwBA,EAAa,CAAE,EAEjH,GADAA,EAAa3E,MAAMD,QAAQ4E,GAAcA,EAAaC,EAAgBD,cAAc,IAC/E3E,MAAMD,QAAQ4E,GAAe,MAAM,IAAIzB,MAAM,oCAClD,MAAM2B,EAAS,CAACR,EAAS,CAAA,IAAOtC,EAAStB,EAAqBC,EAAiB2D,GACzES,EAAY,CAACtE,WAASoE,IACrB9B,EAAOiC,GAAYC,EAASH,IAAUC,GAC1CA,EAAYtE,QAAQA,GAAMsC,EAAMjB,SAASrB,GAC5C,MACMyE,EADS,CAAChF,QAAS0E,GACFO,KAAIC,IACvB,GAAIA,aAAcrF,EACd,OAAOqF,EAAGzD,UAAS,CAAC0D,EAAIC,EAAIhB,KACxBU,EAASF,EAAOR,GAASA,GAClB,KAAOvB,EAAMnC,aAAemC,EAAMH,SAAQ,KAExD,IAGL,OADAG,EAAMlB,WAAU,IAAMqD,EAAQC,KAAI3C,GAAMA,aAAcT,UAAYS,QAC3DO,GAEX7C,KAAK+D,KAAM,CAAEjC,EAAW,KAAM9B,KAAKC,OAAOyE,EAAe,KAAOD,EAAoB3C,EAAU4C,IAAe9E,OAC7GwB,OAAOiE,QAAQC,GAAWL,KAAI,EAAEM,EAAMC,KAAaxF,KAAK+D,IAAIwB,GAAQ,CAACzD,EAAW,KAAM9B,KAAKC,OAAOyE,EAAe,KAAOD,EAAoB3C,EAAU4C,EAAcc,KACpKxF,KAAK+C,KAAM,CAAE9C,EAAOmE,EAAS,CAAEf,QAAS,MAAOpD,MAAOA,MAClD,GAAIS,EAAa,MAAM,IAAIuC,MAAM,mEACjC,GAAqB,iBAAVmB,EAAoB,MAAM,IAAInB,MAAM,8BAC/C,GAAIhD,aAAiBuE,QACjB,OAAOvE,EAAMwF,MAAKlG,GAAKS,KAAK+C,IAAIxD,KAEhCU,aAAiBJ,IAASI,EAAQA,EAAMA,OACxCA,aAAiB4B,WAAU5B,EAAQA,EAAMO,EAAqBC,IAClE,MAAMiF,EAAYlF,EAOlB,OANIkF,IAAczF,IACdA,EAAQkE,EAAWlE,EAAOyF,EAAWtB,GACrC3D,EAAkBiF,EAClBlF,EAAsBP,EA7If,CAACmE,IAAalD,EAAcuB,SAAQH,GAAKA,EAAG9B,EAAqBC,EAAiB2D,IAAO,EA8IhGuB,CAAevB,IAEZ5D,CACV,GAAEZ,OAwCf,SAA4BgG,GAAcnB,oBAAEA,IACxC,MAAM5B,EAAQ+C,EACR9F,EAAU,KACZ,IAAK+C,EAAM/C,QAAS,MAAM,IAAImD,MAAM,2EAA0E,EAE5G4C,EAAc/D,IAChB,KAAMA,aAAoBD,UAAW,MAAM,IAAIoB,MAAM,uCAAsC,EAEzF6C,EAAYC,IAOd,GANIA,aAAiBlG,IACjBkG,EAAQA,EAAM9F,OAEd8F,aAAiBlE,WACjBkE,EAAQlD,EAAM5C,MAAM+F,UAAUD,IAE9BE,MAAMF,GAAQ,MAAM,IAAI9C,MAAM,qEAClC,OAAO8C,GAEXlD,EAAMkB,IAAIkB,IAAOnD,IACb+D,EAAW/D,GACX,MAAMxB,EAAc,CAACf,EAAG6C,IAAM,CAAC2C,EAASxF,GAAG,GAAIwF,EAAS3C,GAAG,IACrD8D,EAAW3G,GAAMuC,KAAYvC,EAAGsD,GAChCsD,EAAYtD,EAAM5C,MAAMgF,IAAI3E,GAClC,IAAI8F,EAAcD,EAAUlB,IAAIiB,GAChC,MAAOG,EAAOC,GAAYvB,EAASqB,GAC7BxB,EAAS,IAAMuB,EAAUlB,KAAI,EAAE1F,EAAG6C,GAAI2D,KACnC3D,EAAE1B,aAAa0B,EAAEW,IAAIgD,GACrBxG,EAAEmB,aAAanB,EAAEwD,IAAIF,EAAM5C,MAAM8F,GAAO,IAiBjD,OAfAlD,EAAMpB,UAAU8C,IACZ,GAAI4B,EAAUI,OAAShC,EAAIgC,OAAQ,CAC/B,MAAMC,EAAajC,EAAIgC,OACjBE,EAAMN,EAAUI,OACtBJ,EAAUhE,OAAOqE,EAAYC,GAAKxB,KAAIyB,GAAKA,EAAEzB,KAAI7C,GAAKA,EAAEM,SAAQ,OAChE4D,EAASnE,OAAOqE,EAAYC,EAC/B,MAAM,GAAIN,EAAUI,OAAShC,EAAIgC,OAAQ,CACtC,MAAMC,EAAaL,EAAUI,OAC7BJ,EAAUlE,QAAQsC,EAAIvB,MAAMwD,GAAYvB,IAAI3E,IAC5C6F,EAAUlB,KAAI,GAAIc,GAAQ3D,IAAM2D,EAAMhD,IAAIX,KAC1CkE,EAASrE,QAAQkE,EAAUnD,MAAMwD,GAAYvB,IAAIiB,GACpD,CACDtB,GAAQ,IAGLyB,GAEXxD,EAAMkB,IAAIjC,SAAYA,IAClB,KAAMA,aAAoBD,UAAW,MAAM,IAAIoB,MAAM,mCACrD,OAAOJ,EAAMkB,KAAI,IAAMjC,GAAQ,EAEnC,MAAM6E,EAAS,CAAC7D,EAAM6D,KAElB,GADA7G,IACI+C,EAAM5C,MAAM0G,aAAmB9E,SAAU,CACzC,MAAM+E,EAAc/D,EAAM5C,MAAM0G,MAAW7D,GAC3C,OAAOD,EAAME,IAAI,IAAIF,EAAM5C,OAAQ,CAAEoD,QAAS,MAAOsD,SAAQ7D,OAAM8D,eACtE,GAKL/D,EAAME,IAAIZ,OAAS,IAAIW,IAAS6D,EAAO,IAAI7D,GAAO,UAClDD,EAAME,IAAI8D,OAAS,CAACC,EAAOC,EAAc,KACrC,MAAMH,EAAc/D,EAAM5C,MAAMkC,OAAO2E,EAAOC,GAC9C,OAAOlE,EAAME,IAAI,IAAIF,EAAM5C,OAAQ,CAAEoD,QAAS,MAAOsD,OAAQ,SAAU7D,KAAM,CAACgE,EAAOC,GAAcH,eAAa,EAEpH/D,EAAME,IAAIiE,KAAO,CAACjB,EAAO9F,KAGrB,GAFAH,KACAiG,EAAQD,EAASC,KACJ,EAAG,CACR9F,aAAiB4B,WACjB5B,EAAQA,EAAM4C,EAAM5C,MAAM8F,GAAQA,EAAOlD,EAAM5C,QAEnD,MAAM2G,EAAc/D,EAAM5C,MAAMkC,OAAO4D,EAAO,EAAG9F,GACjD,OAAO4C,EAAME,IAAI,IAAIF,EAAM5C,OAAQ,CAAEoD,QAAS,MAAOsD,OAAQ,OAAQ7D,KAAM,CAACiD,EAAO9F,GAAQ2G,eAC9F,GAEL/D,EAAME,IAAId,KAAO,IAAIoE,IAAUM,EAAO,IAAIN,GAAQ,QAClDxD,EAAME,IAAIkE,IAAM,IAAMN,EAAO,GAAI,OACjC9D,EAAME,IAAImE,MAAQ,IAAMP,EAAO,GAAI,SACnC9D,EAAME,IAAIoE,QAAU,IAAId,IAAUM,EAAO,IAAIN,GAAQ,SACrDxD,EAAME,IAAIqE,QAAU,IAAMT,EAAO,GAAI,WACrC9D,EAAME,IAAIsE,KAAO,IAAIhB,IAAUM,EAAO,IAAIN,GAAQ,QAClDxD,EAAME,IAAIuE,OAAS,CAACC,KAAczE,KAC9BhD,IACA+F,EAAW0B,GACX,MAAMX,EAAc/D,EAAM5C,MAAMqH,OAAOC,KAAczE,GACrD,OAAOD,EAAME,IAAI6D,EAAa,CAAEvD,QAAS,MAAOsD,OAAQ,SAAU7D,KAAM,CAACyE,KAAczE,GAAO8D,eAAa,EAE/G/D,EAAME,IAAIC,MAAQ,IAAIF,KAClBhD,IACA,MAAM8G,EAAc/D,EAAM5C,MAAM+C,SAASF,GACzC,OAAOD,EAAME,IAAI6D,EAAa,CAAEvD,QAAS,MAAOsD,OAAQ,QAAS7D,OAAM8D,eAAa,EAExF/D,EAAME,IAAIyE,KAAO,CAACC,EAAY,EAAC1F,EAAG2F,IAAMA,EAAI3F,MACxCjC,IACA+F,EAAW4B,GACX,MAAM9D,EAAWd,EAAM5C,MAAM+C,QACvB4D,EAAc/D,EAAM5C,MAAMuH,KAAKC,GACrC,OAAIb,EAAYe,OAAM,CAACC,EAAM7B,IAAU6B,IAASjE,EAASoC,KAAgBlD,EAAM5C,MACxE4C,EAAME,IAAI6D,EAAa,CAAEvD,QAAS,MAAOsD,OAAQ,OAAQ7D,KAAK+E,UAAWjB,eAAa,EAEjG/D,EAAME,IAAIkC,IAAM,CAAC6C,EAAYC,EAAUlF,EAAM5C,SACzCH,IACA+F,EAAWiC,GACX,MAAMlB,EAAc/D,EAAM5C,MAAMgF,IAAI6C,KAAehF,MACnD,OAAOD,EAAME,IAAI6D,EAAa,CAAEvD,QAAS,MAAOsD,OAAQ,MAAO7D,UAAM8D,eAAa,CAE1F,CAlJYoB,CAAmBhI,KAAM,CAAEyE,wBAC3BrD,OAAOiE,QAAQlE,GAAS8D,KAAI,EAAEgD,EAAE1I,KAAKS,KAAK+C,IAAIkF,GAAGC,GAASlI,KAAK+C,IAAIxD,aAAasC,SAAUtC,EAAEiB,EAAoB0H,GAAS3I,KACrHU,aAAiBuE,SACjBvE,EAAMwF,MAAKlG,GAAKS,KAAK+C,IAAIxD,IAEhC,GAEFU,EAAOM,GACd,CACA,MAAM+E,EAAY,CACd6C,MAAM5I,GACF,IAAKQ,MAAMD,QAAQP,GAAI,MAAM,IAAI0D,MAAM,uCACvC,OAAO1D,CACV,EACD6I,OAAO7I,GACH,GAAgB,iBAALA,EAAe,MAAM,IAAI0D,MAAM,wCAC1C,OAAO1D,CACV,EACD8I,OAAO9I,GACH,GAAgB,iBAALA,EAAe,MAAM,IAAI0D,MAAM,wCAC1C,OAAO1D,CACV,EACD+I,SAAS/I,GACL,GAAgB,mBAALA,EAAiB,MAAM,IAAI0D,MAAM,0CAC5C,OAAO1D,CACV,EACDgJ,QAAQhJ,GACJ,GAAgB,kBAALA,EAAgB,MAAM,IAAI0D,MAAM,yCAC3C,OAAO1D,CACV,EACDiJ,OAAOjJ,GACH,GAAgB,iBAALA,EAAe,MAAM,IAAI0D,MAAM,wCAC1C,OAAO1D,CACV,EACDkJ,OAAOlJ,GACH,GAAgB,iBAALA,EAAe,MAAM,IAAI0D,MAAM,wCAC1C,OAAO1D,CACV,GA+GU,SAASwF,EAAS9E,EAAOM,EAAQjB,GAU5C,OATIW,aAAiBJ,EAEbU,aAAiBsB,UAAYtB,IAAUjB,GAASW,EAAM2B,SAASrB,GAC5DR,MAAMD,QAAQG,IAAUA,EAAM,aAAcJ,GAAWI,EAAM,KAAOA,EAAM,GAAG8C,KACpF9C,EAAQA,EAAM,GACVM,aAAiBsB,UAAYtB,IAAUjB,GAASW,EAAM2B,SAASrB,IAEnEN,EAAQK,EAAYL,EAAOM,GAExB,CAACN,EAAOA,EAAM8C,IACzB,CAGA3B,OAAOiE,QAAQC,GAAWL,KAAI,EAAEM,EAAMhF,KAAWwE,EAASQ,GAAStF,GAAU8E,EAAS9E,EAAOM,KAC7FwE,EAASrF,QAAUA,ECxUnB,MAAMgJ,EAAUjJ,OAAO,SACR,SAASkJ,EAAO1I,GAC3B,MAAON,EAAKiJ,GAAa7D,EAAS9E,GAC5B4I,EAAOzH,OACb,OAAOyH,EAAOxH,OAAO,UACjBuC,cACIiF,EAAO/E,eAAe9D,KAAK,UAAU,CACjC+D,KAAI,IAAKpE,EAAIM,OAAOL,OACpBmD,KAAMwB,GAAMqE,EAAUrE,IAAM3E,OAC5BoE,YAAW,EACX8E,cAAa,IAEjBD,EAAO/E,eAAe9D,KAAK,WAAW,CAClCC,OAAQqC,GAAK3C,EAAI8B,SAASa,IAAK1C,OAC/BoE,YAAW,GAElB,CACDrC,UAAUW,GAAI,OAAO3C,EAAIgC,UAAUW,EAAG,CACtCI,QAAQJ,GAAI,OAAO3C,EAAI+C,SAAQ,EAAK,CACpCK,IAAIT,GAAI,OAAOsG,EAAUtG,EAAG,CACvB,eAAa,OAAOoG,CAAS,GAE1C,CCnBO,SAASK,EAAUjH,EAAUkH,EAAS,IACzC,IAAKjJ,MAAMD,QAAQkJ,GAAS,MAAM,IAAI/F,MAAM,8BAC5C,MAAMgG,EAAU,GAChB,IAAIpC,EACJ,MAAMsB,EAAQ,IAAIa,GACZE,EAAWxC,GAAKA,aAAa7G,EAAU6G,EAAEzG,MAAQyG,EAQvD,OANAyB,EAAM1F,SAAQ,CAACyC,EAAI9C,KACX8C,aAAcrF,GACdoJ,EAAQhH,KAAKiD,EAAGzD,UAAS,KAHpBW,KAAIoC,QAAQ2E,UAAU1D,MAAK,IAAMoB,EAAS/E,EAAS,IAAIqG,EAAMlD,IAAIiE,IAAW9G,IAAG,EAGpDwC,CAAOxC,EAAE,IAC5C,IAELgH,qBAAoB,IAAMvC,EAAS/E,EAAS,IAAIqG,EAAMlD,IAAIiE,KAAY,KAC/D,KACHD,EAAQ9G,OAAO,EAAE8G,EAAQ1C,QAAQtB,KAAI3C,GAAMA,QACvCuE,aAAkBhF,UAAUgF,GAAQ,EAAG,IAAIsB,GAAOlD,IAAIiE,GAAU,CAE5E,CCnBO,SAASG,EAAgBvH,EAAUkH,EAAS,IAC/C,IAAKjJ,MAAMD,QAAQkJ,GAAS,MAAM,IAAI/F,MAAM,8BAC5C,MAAMgG,EAAU,GAChB,IAAIpC,EACJ,MAAMsB,EAAQ,IAAIa,GACZE,EAAWxC,GAAKA,aAAa7G,EAAU6G,EAAEzG,MAAQyG,EACjD9B,EAAOxC,GAAIyE,EAAS/E,EAAS,IAAIqG,EAAMlD,IAAIiE,IAAW9G,GAO5D,OANA+F,EAAM1F,SAAQ,CAACyC,EAAI9C,KACX8C,aAAcrF,GACdoJ,EAAQhH,KAAKiD,EAAGzD,UAAS,KAAOmD,EAAOxC,EAAE,IAC5C,IAELwC,GAAQ,GACD,KACHqE,EAAQ9G,OAAO,EAAE8G,EAAQ1C,QAAQtB,KAAI3C,GAAMA,QACvCuE,aAAkBhF,UAAUgF,GAAQ,EAAG,IAAIsB,GAAOlD,IAAIiE,GAAU,CAE5E,CCjBO,SAASI,EAASC,EAAQ,IAC7B,GAAkB,iBAARA,EAAkB,MAAM,IAAItG,MAAM,8BAC5C,MAAO,IACA7B,OAAOiE,QAAQkE,GAAOC,QAAO,CAACC,GAAOC,EAAKzJ,MAAY,IAAKwJ,EAAMC,CAACA,GAAe,aAARA,GAAsBA,EAAIC,WAAW,MAAc5E,EAASrF,QAAQO,GAAxBA,EAAwC8E,EAAS9E,GAAO,MAAO,CAAA,GAE/L,CHiBA0I,EAAOiB,OAAQjK,GAAmB,iBAALA,GAAgB+I,IAAY/I,EAAI,YAAYC,OIxBzE,MAAMiK,EAAe,CACjBC,eAAgB,IAAIhH,IAAS,IAAIA,GACjCiH,cAAe,CAACC,EAAMpD,IAAgB,CAACoD,EAAMpD,GAC7CqD,YAAanI,GAAYA,EACzBoI,wBAAuB,GAEpB,SAASC,EAASC,EAAUP,GAC/B,GAAuB,iBAAZO,EAAsB,MAAM,IAAInH,MAAM,+BACjD,MAAM6G,eAAEA,EAAeD,EAAaC,eAAcC,cAAEA,EAAcF,EAAaE,cAAaE,YAAEA,EAAYJ,EAAaI,YAAWC,uBAACA,EAAuBL,EAAaK,wBAA0BE,EAC3LC,EAAS,IAAIpJ,IAOnB,MAAO,CANYa,IACf,KAAMA,aAAoBD,UAAW,MAAM,IAAIoB,MAAM,kCAGrD,OAFAnB,EAAWmI,EAAYnI,cACCD,UAAUwI,EAAO3G,IAAI5B,GACtC,IAAMuI,EAAO5G,OAAO3B,EAAQ,EAEpB,CAACkI,KAAQM,KACxB,MAAMxH,EAAOgH,EAAeE,KAAQM,GAC9B1D,EAAcyD,EAAO5H,SAAQH,GAAMA,OAASvC,MAAMD,QAAQgD,GAAMA,EAAK,CAACA,MAE5E,OADGoH,GAAuBG,EAAO9H,QAC1BwH,EAAcC,EAAMpD,EAAW,EAE9C,CCpBO,SAAS2D,EAAQzI,EAAUkH,EAAS,IACvC,IAAKjJ,MAAMD,QAAQkJ,GAAS,MAAM,IAAI/F,MAAM,8BAC5C,MAAMgG,EAAU,IACTpG,EAAMiC,GAAUC,IACjBoD,EAAQ,IAAIa,GACZE,EAAWxC,GAAKA,aAAa7G,EAAU6G,EAAEzG,MAAQyG,EACjD9B,EAAOxC,GAAI0C,EAAShD,EAAS,IAAIqG,EAAMlD,IAAIiE,IAAW9G,IAQ5D,OAPA+F,EAAM1F,SAAQ,CAACyC,EAAI9C,KACX8C,aAAcrF,GACdoJ,EAAQhH,KAAKiD,EAAGzD,UAAS,KAAOmD,EAAOxC,EAAE,IAC5C,IAELwC,GAAQ,GACR/B,EAAMlB,WAAU,IAAIsH,EAAQ9G,OAAO,EAAE8G,EAAQ1C,QAAQtB,KAAI3C,GAAMA,UACxDO,CACX,CCfA,MAAM2H,EAAW,IAAIC,QACd,SAASC,EAAEC,GAChB,KAAMA,aAAeC,MACnB,MAAM,IAAI3H,MAAM,qCAClB,GAAIuH,EAASzG,IAAI4G,GAAM,OAAOH,EAASzG,IAAI4G,GAC3C,IAAIjK,GAAc,EACdmK,EAAc,GAClB,MAAOC,EAASC,GAAiBZ,EAAS,CAAED,wBAAwB,KAC7Dc,EAAaC,GAAqBd,EAAS,CAACD,wBAAwB,IAC3E,IAAIgB,GAAU,EACdJ,GAAQ,IAAOI,GAAU,IACJP,EAAIQ,WACzB,MAAMC,EAAU,IAAIC,KACdC,EAAO,IAAID,KAoCjB,MA2CME,EAAU,CACdC,SAAU,IA/EE,KAgFZC,KA7CW,CAACC,EAAUzL,IAChB0K,aAAegB,QACjBD,QAAsBtI,IAAVnD,GACd0K,EAAIiB,aAAaF,EAAUzL,GAAS,IAC7B0K,EAAIkB,aAAaH,IACfA,EACFf,EAAIkB,aAAaH,GAEnBf,EAAImB,WAP2B,KA4CjCC,MAnCO,CAACC,EAAc/L,KAC3B,GAAG0K,aAAegB,QAAQ,CACxB,QAAWvI,IAARnD,EACD,OAAO0K,EAAIoB,MAAMC,GAEnBrB,EAAIoB,MAAMC,GAAc/L,CACzB,CACD,OAAO0K,EAAIoB,MAAMC,EAAY,EA4BlBC,SA1BKC,GAAcvB,aAAegB,SAAShB,EAAIwB,UAAUzI,IAAIwI,GA0BpDE,SAzBJF,GAAcvB,aAAegB,SAAShB,EAAIwB,UAAUE,SAASH,GAyBhDI,YAxBVJ,GAAcvB,aAAegB,SAAShB,EAAIwB,UAAUtF,OAAOqF,GAwBrCK,YAvBtBL,GAAcvB,aAAegB,SAAShB,EAAIwB,UAAUK,OAAON,GAuBzBhJ,GAtB5C,CAACqC,EAAMtF,KAChB,MAAMmK,EAAQqC,GAAGxM,aAAiB4B,UAAU5B,EAAMwM,GAElD,OADA9B,EAAI+B,iBAAiBnH,EAAK6E,GACnB,IAAIO,EAAIgC,oBAAoBpH,EAAK6E,EAAO,EAmBSoB,SAjBzC,IA/DH,KAiFZR,cAAYC,oBAAkBH,UAAQC,gBAAc6B,YAhFlC,IAClBpI,QAAQ2E,UAAU1D,MAAK,KACjBkF,EAAIkC,YACNlC,EAAImC,MAAM1B,GACVT,EAAImC,MAAMxB,IACDA,EAAKuB,YACdvB,EAAKwB,MAAM1B,GAENA,KAyET1I,QAjBc,CAACF,GAAU,KACrBmI,aAAeC,QAAUD,aAAeoC,mBAC1CpC,EAAI9D,SAEFnG,IACJmK,EAAY5F,KAAK3C,GAAOA,aAAcT,UAAYS,EAAGE,KACrD9B,GAAc,EACdmK,EAAc,GACVF,aAAeU,MAAQ7I,IACzBmI,EAAIX,KAAO,IACZ,EAOOrI,UAhEV,SAAmBG,GAEjB,GATc,MACd,GAAIpB,EACF,MAAM,IAAIuC,MACR,4FAEO,EAGX+J,GACIlL,aAAoBjC,GAAWiC,EAAS7B,iBAAiB4B,SAAU,CACrE,MAAMgB,EAAQf,EACdA,EAAW,IAAIgB,KACb,KAAMD,EAAM5C,iBAAiB4B,UAC3B,MAAM,IAAIoB,MAAM,sCAClBJ,EAAM5C,SAAS6C,EAAK,CAEvB,MAAM,GAAI/C,MAAMD,QAAQgC,GAEvB,YADAA,EAASmD,KAAK3C,GAAO8H,QAAQ6C,UAAU3K,KAGrCR,aAAoBD,UACtBgJ,EAAY5I,KAAKH,EAEpB,EAiDCoJ,QAAS,IAAMA,EACfxK,YAAa,IAAMA,EACnBwM,YAAa,IAAMA,YACnBC,UAAW,IAAMC,QACbhC,cACF,OAAOA,CACR,EACD7J,GAAI,KAENH,OAAOC,OAAOkK,GACdA,EAAQP,aAAY,KACdL,EAAIkC,YACNlC,EAAImC,MAAMxB,EACX,IAEH,MAAM/J,EAAG8L,aAAY,KAChB1C,EAAI2C,gBACLC,cAAchM,GACd0J,EAAkBN,EAAI2C,eACvB,GACD,IAEF,OADA9C,EAASzH,IAAI4H,EAAKY,GACXA,CACT,CCpHA,MAAMiC,EAAc,CAChBC,GAAK,CACD,EAAEzD,GAAM,IAEZ0D,GAAK,CAEJ,GAECC,EAAM,GCDL,SAASC,KAA0BC,GACtC,OAAO,IAAIC,OAAO,MAPf,YAA0BD,GAC7B,OAAOA,EAAKrE,QAAO,CAACuE,EAASC,IAAM,IAAIF,OAAOC,EAASE,OAJ3D,SAAsBD,GAClB,MAAmB,iBAALA,EAAcA,EAAIA,EAAIC,MACxC,CAEkEC,CAAaF,KAC/E,CAK4BG,IAAiBN,GAAMI,UACnD,CACO,SAASG,KAAqBP,GACjC,OAAO,IAAIC,OAAO,IAhBf,YAAyBD,GAC5B,OAAOA,EAAKrE,QAAO,CAACuE,EAASC,IAAM,IAAIF,OAAOC,EAASE,OAAOD,EAAIC,SACtE,CAc0BI,IAAgBR,GAAMI,UAChD,CACO,SAASK,KAAqBT,GACjC,OAAOO,EAAkBP,EAAKrE,QAAO,CAACuE,EAASC,IAAM,IAAIF,OAAOC,EAASE,OAAO,IAAID,EAAIC,UAC5F,EDNO,UAAiBM,KAACA,EAAIC,KAACA,EAAK,CAACf,GAAIzD,GAAO,UAAU0D,GAAI1D,GAAO,aAChE,GAAG2D,EAAMc,SAASF,GAAO,MAAM,IAAItL,MAAM,2BACzC,GAAiB,iBAAPuL,EAAgB,MAAM,IAAIvL,MAAM,0BAC1C0K,EAAM1L,KAAKsM,GACXnN,OAAOiE,QAAQmJ,GAAMvJ,KAAI,EAAEyJ,EAAKzO,MAC5BuN,EAAakB,GAAMH,GAAOvE,IACtB,KAAK/J,aAAiB4B,UAAW,MAAM,IAAIoB,MAAM,yCACjD,OAAOhD,EAAM+J,EAAI,CACpB,GAET,CAgCA2E,CAAQ,CACJJ,KAAK,EACLC,KAAK,CACDf,GAAIzD,GACO,WAAWA,IAEtB0D,GAAI1D,GACO,WAAWA,OE9DvB,MAAM4E,UAAoB7O,MAClB8O,oBAAW,MAAO,kDAAoD,CACtEC,yBAAgB,MAAO,qEAAuE,CAC9FC,0BAAiB,MAAO,sEAAwE,QAEvG/O,KAAKgP,MAAQ,SAAUC,EAAS,GAAIC,GAAiB,GACjD,GAAqB,iBAAVD,EAAoB,MAAM,IAAIhM,MAAM,4CAC/C,MAAM+K,EAAMkB,EAAiBZ,EAAkBtO,KAAK6O,QAAU7O,KAAK6O,OAQnE,OAPeI,EAAOD,MAAMhB,GAAKxE,QAAO,CAAC2F,EAAGvH,KACxC,IAAKA,EAAM,OAAOuH,EAClB,MAAMC,EAAIpP,KAAKqP,MAAMzH,GAGrB,OAFIwH,GAAKF,aAA0BrN,WAAU+F,EAAOsH,EAAeE,IACnED,EAAElN,KAAK2F,GACAuH,IACR,GAEN,EACDnP,KAAKsP,WAAa,SAAUL,EAAQhP,EAAQ,IACxC,GAAqB,iBAAVgP,EAAoB,MAAM,IAAIhM,MAAM,4CAC/C,OAAOgM,EAAOK,WAAWtP,KAAK+O,cAAc,CAACQ,EAAOxJ,EAAOR,IAAStF,aAAiB4B,SAAW5B,EAAM,CAAEsP,QAAOxJ,QAAOR,SAAUtF,GACnI,EACDD,KAAKqP,MAAQ,SAAUJ,EAAS,GAAIO,EAAO,MACvC,GAAqB,iBAAVP,EAAoB,MAAM,IAAIhM,MAAM,4CAC/C,MAAMwM,EAAS,sEAAsEC,KAAKT,GACpFhP,EAAQuP,EAAOxP,KAAKgP,MAAMC,GAAQ,EAAGlJ,WAAYyJ,EAAKzJ,KAAU,KAChE4J,EAAc1P,EAAQA,EAAM2P,KAAK,IAAM,GAC7C,OAAOH,EAAS,CACZ1J,MAAO0J,EAAOI,OAAO9J,MACrBR,KAAMkK,EAAOI,OAAOtK,KACpBgK,MAAOE,EAAOF,MACdtP,QAAO0P,cAAaH,QACpB,IACP,CACJ,CACD5L,eAAe4L,GACX3L,QACA7D,KAAKiC,QAAQuN,GACbxP,KAAK8P,WAAW,CAAE,CACrB,ECpCL,MAAMC,EAAyB,CAAE,EAG3BC,EAAkB,CACpBC,GAAI,KACJvE,SAAU,GACVwE,UAAW,GACXC,cAAe,GACf5M,IAAK,GACL6M,UAAW,CAAE,EACbrK,MAAO,GAEJ,MAAMsK,EACTP,GAAe,IAAKC,GAChBD,iBAAe,OAAO9P,MAAK8P,CAAa,CACxCA,eAAWA,GACX1O,OAAO6C,OAAOjE,MAAK8P,EAAaA,EACnC,CACDN,KAAO,IAAIZ,EACX0B,WAAa,CACTC,SAAQL,UAAEA,EAASD,GAAEA,GAAMD,IACvBE,EAAUA,aAAqBrQ,EAAQqQ,EAAUjQ,MAAMiQ,aAC/BrO,SACpB6I,EAAEuF,GAAItO,UAAUuO,EAAUD,GAG9BO,QAAQC,KAAK,+CAChB,EACDC,aAAYR,UAAEA,EAASD,GAAEA,EAAE1M,IAAEA,GAAQyM,GACjC,MAAMW,EAA8B,CAAC,UAAW,QAAS,aAAc,OAAQ,MAAO,SAAU,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,SAAU,OAAQ,MAAO,IAAK,UAAW,QAC7K,GAAIA,EAA4BlC,SAASwB,EAAGW,YAAcX,EAAGW,UAAUnC,SAAS,KAAM,CAClF,IAAI3M,EACAoO,aAAqBrQ,IAASqQ,EAAYA,EAAUjQ,OACpDiQ,aAAqBrO,WAAUC,EAAWoO,GAC9C,MAAMW,EAAc,IAAIZ,EAAG9E,YACrBG,EAAO2E,EAAGa,aAAa,CAAEC,KAAc,WAARxN,EAAmB,SAAW,SAC7DqD,EAAc9E,aAAoBD,SAAWC,EAAS,CAAEmO,KAAI3E,OAAM0F,SAAUH,IAAiBA,EAC7FG,EAAWjR,MAAMD,QAAQ8G,GAAeA,EAAc,CAACA,GAC7DqJ,EAAGgB,UAAY,GACf3F,EAAK4F,UAAUF,EAC/B,MACgBR,QAAQC,KAAK,aAAaR,EAAGW,mMACeD,EAEnD,EACDQ,YAAWjB,UAAEA,EAASD,GAAEA,EAAErE,aAAEA,GAAiBoE,GACzC,IAAIoB,EACJ,GAAIlB,aAAqBrQ,EAAS,CAC9B,MAAM+E,EAAS,CAAC8J,EAAMzO,KACdmR,aAAmBvP,UAAUuP,IACjCA,EAAUxF,EAAaqE,EAAIvB,EAAMzO,GAAS,GAAG,EAEjD,OAAOiQ,EAAUzO,UAAS,CAACxB,EAAO0D,KAC9B,GAAI1D,GAAyB,iBAATA,EAChB,GAAI0D,GAA+B,iBAAZA,EAAsB,CACzB1D,EAAMyL,WAAa/H,EAAS+H,UAAYzL,EAAMiQ,YAAcvM,EAASuM,WAEjFtL,EAAO3E,EAAMyL,SAAUzL,EAAMiQ,WAAa,GAE1E,MAC4BtL,EAAO3E,EAAMyL,SAAUzL,EAAMiQ,WAAa,SAG9CtL,EAAO3E,EAAO,IAElB,OAAOmR,KACR,EACN,CACD,OAAOxF,EAAaqE,EAAIC,GAAW,EACtC,EACDmB,KAAInB,UAAEA,EAASD,GAAEA,EAAElK,MAAEA,EAAKiE,KAAEA,EAAMzG,IAAAA,GAAOyM,GACrCjK,EAAQlF,KAAKC,SACoB,iBAAtBkJ,EAAKsH,gBAA2BtH,EAAKsH,cAAgB,CAAE,GAClE,MAAMpI,EAAYjJ,GAAUA,aAAiB4B,SAAW5B,EAAMgQ,KAAQhQ,EAChEsR,EAAY,IAAInQ,OAAOoQ,OAAOxH,EAAKsH,eAAe3J,OAAM8J,GAAUA,IAElEC,EAAc,CAACC,EAAYJ,MAAiB7G,EAAEuF,GAAIrD,cACnDnH,MAAK2F,GACEA,EAAQyB,WAILzB,EAAQyB,YAAc8E,EAAYvG,EAAQ0B,MAAMmD,GAAMA,EAAGpJ,SAFrD6D,EAAEuF,GAAIjF,aAAY,IAAIN,EAAEuF,GAAIrD,cAAcnH,MAAK,IAAI8L,IAAgBnG,EAAQ0B,MAAMmD,GAAMA,EAAGpJ,eAI7G,OAAIqJ,aAAqBrQ,EACdqQ,EAAUzO,UAAUxB,IACvB,MAAMV,EAAE2J,EAASjJ,GAGjB,OAFA+J,EAAKsH,cAAcvL,GAAa,SAALxC,GAAchE,EAAEA,EAC3CmS,IACO,YACI1H,EAAKsH,cAAcvL,GAC1BmK,EAAUxN,SAAQ,EAAK,CAC1B,IACF,IAEHsH,EAAKsH,cAAcvL,GAASmD,EAASgH,GACrCwB,IAEG,IAAM1H,EAAKsH,cAAcvL,IAAS,EAC5C,EACD6L,MAAK3B,GAAEA,EAAEC,UAAEA,GAAcF,GAIrB,GAHIE,aAAqBrQ,IACrBqQ,EAAUA,EAAUjQ,OAEpBiQ,aAAqBrO,SACrB,OAAOqO,EAAUD,GACXtH,EAAOiB,MAAMsG,KACnBA,EAAU2B,QAAQ5B,EAEzB,EACD6B,OAAQ7B,GAAItF,EAAGuF,UAAEA,GAAcF,GAC3B,GAAIE,aAAqBrQ,EACrB,OAAOqQ,EAAUzO,UAAUsQ,IACvBpH,EAAIqH,QAAUD,EACP,IAAM7B,EAAUxN,SAAQ,MAChC,GAEHiI,EAAIqH,QAAU9B,CAErB,EACD+B,OAAMhC,GAAEA,EAAE1M,IAAEA,EAAG6M,UAAEA,EAASF,UAAEA,GAAcF,GACtC,MAAMkC,EAAS,GACXhC,aAAqBrQ,GACrBqS,EAAOjQ,KAAKiO,EAAUzO,UAAUlC,IACxBgE,KAAO0M,EACPA,EAAG1M,GAAOhE,EAEV0Q,EAAGrE,aAAarI,EAAKhE,GAElB,IAAM2Q,EAAUxN,SAAQ,MAChC,IAEP,MAAMmH,EAAe,KACjB,MAAM5J,EAAQsD,KAAO0M,EAAKA,EAAG1M,GAAO0M,EAAGpE,aAAatI,GAChD2M,aAAqBrQ,GAASqQ,EAAUnN,IAAI9C,EAAM,EAM1D,GAJAiS,EAAOjQ,QAAQb,OAAO+Q,KAAK/B,GAAWnL,KAAImN,IACtCnC,EAAGvD,iBAAiB0F,EAAWvI,GACxB,IAAMoG,EAAGtD,oBAAoByF,EAAWvI,OAEd,GAAjCzI,OAAO+Q,KAAK/B,GAAW7J,OAAa,CACpC,MAAM6L,EAAY,CAAC,SAAS3D,SAASwB,EAAGW,WAAa,QAAU,SAC/DX,EAAGvD,iBAAiB0F,EAAWvI,GAC/BqI,EAAOjQ,MAAK,IAAMgO,EAAGtD,oBAAoByF,EAAWvI,IACvD,CACD,MAAO,IAAMqI,EAAOjN,KAAI3C,GAAMA,KACjC,EACD+P,aAAYpC,GAAEA,EAAE1M,IAAEA,EAAG6M,UAAEA,EAASF,UAAEA,GAAcF,GACxCE,aAAqBrQ,IAASqQ,EAAYA,EAAUjQ,OAChC,iBAAbiQ,GACP9O,OAAO6C,OAAOjE,KAAMkQ,EAE3B,GAELoC,UAAU9C,EAAOxP,KAAKwP,MAClB,KAAMA,aAAgBZ,GAAc,MAAM,IAAI3L,MAAM,sCACpD,MAAMsP,EAAU,EAAGxM,WAAY/F,KAAKwP,KAAKzJ,GACnCyM,EAAc,CAACxI,EAAMN,KAOvB,GAAIA,KAAOM,EAAM,CACb,GAAIN,EAAI+E,SAAS,MAAQ/E,EAAI+E,SAAS,MAAsB,KAAd/E,EAAI+I,IAAI,GAAW,CAC7D,MAAMC,EAAShJ,EAAIiJ,QAAQ,KAC3BjJ,EAAMA,EAAI1G,MAAM,EAAG0P,EACtB,CACD,MAXO,MACP,IAAItQ,EAAIvB,KAAK+R,MAAsB,IAAhB/R,KAAKC,UACxB,KAAQ4I,EAAM,IAAItH,OAAS4H,GAAQ5H,IAEnC,OADAsH,GAAO,IAAItH,IACJsH,EAOAmJ,EACV,CACD,OAAOnJ,GAEX1J,KAAKuJ,MAAQnI,OAAOiE,QAAQrF,KAAKuJ,OAAOC,QAAO,CAACD,GAAQmC,EAAUzL,MAE9D,MAAM6S,EAAmBlE,EAAYS,MAAM3D,EAAU1L,KAAKwP,MACpDuD,EAA6B,iBAAT9S,EAAoB2O,EAAYI,MAAM/O,GAAS,GAAIsS,GAAW,CAACtS,IAGrF,QAAQ+S,KAAKD,EAAW,KAASA,EAAW,aAAclT,GAAUkT,EAAW7L,SAC/E,QAAQ8L,KAAKD,EAAWN,IAAI,KAASM,EAAW,aAAclT,GAAUkT,EAAW9L,MAEvF,IACIgM,EADAC,GAAgB,EAEpB,MAAMhK,EAAW,KACb,GAAIgK,EAAe,OAAOD,EAE1B,GADAC,GAAgB,EACS,GAArBH,EAAWxM,OAEX,OADA0M,EAAa,GACN,GAEX,GAAyB,GAArBF,EAAWxM,OAEX,OADA0M,EAAaF,EAAW,GACjBA,EAAW,GAEtB,MAAMI,EAAa5I,GAAQ,IAAMwI,EAAWnD,KAAK,KAAMmD,GAEvD,OADAE,EAAaE,EACNA,GAEX,GAAIL,EAAkB,CAClB,IAAIM,GAAc,EAClB,MAAMC,IAAaP,EAAiB7S,MAAMoC,MAAK9C,IACvCA,aAAasC,WACbuR,GAAc,GAEX7T,aAAaM,KAGlByT,EAAa,IAAM/I,GAAQ,KAAO,CACpCmB,SAAUoH,EAAiB7S,MAAMgF,KAAI1F,GAAKA,aAAasC,SAAWtC,EAAEmP,KAAOnP,aAAaM,EAAUN,EAAEW,WAAyB,iBAALX,EAAgBA,GAAGqE,aAAa8K,KAAOnP,IAAGqQ,KAAK,IACvKM,UAAWhH,OACX,IAAI4J,EAAiB7S,QAEzB,GANiD,KAA7B6S,EAAiB7S,MAAM,IAAa6S,EAAiB7S,MAAM,aAAc4B,SAM5E,CACb,MAAMC,EAAWgR,EAAiB7S,MAAM,GAClCsB,EAAKV,KAAK+R,MAAsB,IAAhB/R,KAAKC,UACrByS,GAAoC,KAApBzR,EAAS4M,KAAK,GAAY5M,EAAS4M,KAAO,IAAM5M,EAAS4M,MAAQ,IAAMnN,EAAK,IAClGvB,KAAKsQ,WAAWiD,GAAgBzR,EAChC,IAAI4H,EAAM,aACVA,EAAM8I,EAAYjJ,EAAOG,GACzBoJ,EAAiB7S,MAAM,GAAK,GAC5B6S,EAAiB7S,MAAM,GAAKsT,EAC5B,MAAM9H,EAAO6H,IAEb,OADA/J,EAAMG,GAAO+B,EACNlC,CACV,CAAM,GAAI8J,EAAU,CACjB,IAAI3J,EAAM,aACVA,EAAM8I,EAAYjJ,EAAOG,GACzB,MAAM+B,EAAO6H,IAEb,OADA/J,EAAMG,GAAO+B,EACNlC,CACV,CAAM,GAAI6J,EAAa,CACpB,MAAMI,EAAM,IAAIV,EAAiB7S,OACjC,GAAIuT,EAAI,aAAc3R,UAA0B,GAAd2R,EAAIjN,OAAa,CAC/C,IAAImD,EAAM,UAGV,OAFAA,EAAM8I,EAAYjJ,EAAOG,GACzBH,EAAMG,GAAO8J,EAAI,GACVjK,CAC/B,CAA2B,CACH,IAAIG,EAAM,IAAIoJ,EAAiB7S,OAAOgF,KAAI1F,GAAKA,aAAasC,SAAWtC,EAAEmP,KAAOnP,IAAGqQ,KAAK,IAGxF,OAFAlG,EAAM8I,EAAYjJ,EAAOG,GACzBH,EAAMG,GAAOR,IACNK,CACV,CACrB,CAAuB,GAAIuJ,EAAiB7S,MAAM,aAAcmB,QAA4C,IAAlC0R,EAAiB7S,MAAMsG,OAC7E,MAAa,IAATtG,GACA6S,EAAiB7S,MAAM,GAAG2D,cAAgBxC,QAC9CA,OAAOiE,QAAQyN,EAAiB7S,MAAM,IAAIgF,KAAI,EAAEgD,EAAG1I,MAC/C0I,EAAIuK,EAAYjJ,EAAOtB,GACvBsB,EAAMtB,GAAK1I,CAAC,IAJQgK,EAQxBmC,EAAWoH,EAAiBnD,WAEnC,CACD,IAAI8D,GAAY,EAKhB,MAJgB,KAAb/H,EAAS,KACR+H,GAAY,EACZ/H,EAASA,EAAS1I,MAAM,IAEZ,YAAZ0I,GACAnC,EAAMyH,SAAW/Q,EACVsJ,IAEXmC,EAAW8G,EAAYjJ,EAAOmC,GAC9BnC,EAAMmC,GAAY+H,EAAYlJ,GAAQ,IAAIrB,MAAYA,IAC/CK,KACR,GACN,CACD3F,cAAgB,CAChB2B,KACAgE,MACAoB,GACA+I,GACIA,aAAS,OAAO1T,MAAK0T,CAAO,CAC5BA,WAAOC,GACP,KAAKA,aAAuBtD,GAAc,MAAM,IAAIpN,MAAM,kDAC1DjD,MAAK0T,EAAQC,CAChB,CACGhJ,UACA,OAAO3K,MAAK2K,CACf,CACGA,QAAIiJ,GACJ,GAAG5T,MAAK2K,EAAM,MAAM,IAAI1H,MAAM,+BAC9B,KAAK2Q,aAAoBhJ,MAAO,MAAM,IAAI3H,MAAM,2CAChDjD,MAAK2K,EAAKiJ,CACb,EChSE,MAAMC,UAAuBxD,EAChCzM,YAAY2B,EAAMgE,EAAQ,CAAE,EAAEiG,EAAK,IAAIZ,GACnC,KAAMY,aAAgBZ,GAAc,MAAM,IAAI3L,MAAM,sCACpDY,QACA7D,KAAKuF,KAAOA,EACZvF,KAAKwP,KAAOA,EACZxP,KAAKuJ,MAAQnI,OAAOC,OAAO,IACpBkI,EACHyH,SAAUzH,EAAMyH,UAAW,KAE/BhR,KAAKuJ,MAAMyH,SAAS/L,KAAI,CAAC6O,EAAM/N,KACxB+N,aAAiB/G,mBAChB/M,KAAKuJ,MAAMyH,SAASjL,GAAO,IAAI+N,EAAMC,WACxC,IAEL/T,KAAKsS,UAAUtS,KAAKwP,MACpBxP,KAAK8P,WAAW9P,KAAKwP,KAAKM,WACvB9P,KAAK8P,WAAWvK,KACfvF,KAAKuF,KAAKvF,KAAK8P,WAAWvK,IAE9BnE,OAAOC,OAAOrB,KACjB,ECrBE,MAAMgU,UAAwB3D,EACjCzM,YAAYoN,EAAUxB,EAAK,IAAIZ,GAC3B,KAAMY,aAAgBZ,GAAc,MAAM,IAAI3L,MAAM,sCACpDY,QACA7D,KAAKwP,KAAOA,EACZxP,KAAKuF,KAAO,WACZvF,KAAKuJ,MAAQnI,OAAOC,OAAO,CACvB2P,SAASA,GAAY,KAEzBhR,KAAKsS,UAAUtS,KAAKwP,MACpBpO,OAAOC,OAAOrB,KACjB,ECXE,MAAMiU,UAAoB5D,EAC7BzM,YAAYsQ,EAAM1E,EAAK,IAAIZ,GACvB,KAAMY,aAAgBZ,GAAc,MAAM,IAAI3L,MAAM,sCASpD,OARAY,QACA7D,KAAKwP,KAAOA,EACZxP,KAAKuF,KAAO,OACZvF,KAAKuJ,MAAQnI,OAAOC,OAAO,CACvB8S,UAAWD,EACXlD,SAAU,KAEd5P,OAAOC,OAAOrB,MACXA,KAAKuJ,MAAM4K,qBAAqBvJ,MAC5B5K,KAAKuJ,MAAM4K,qBAAqBpH,kBAC/ByD,QAAQ4D,IAAI,IAAIpU,KAAKuJ,MAAM4K,UAAUJ,YAElC/T,KAAKuJ,MAAM4K,WAElBnU,KAAKuJ,MAAM4K,qBAAqB9D,EAAoBrQ,KAAKuJ,MAAM4K,eAAnE,CACH,ECdL,MAAME,EAAe,CAACvS,EAAUgB,EAAMwR,IAAUxS,EAASyS,MAAMD,EAAOxR,GACtEuR,EAAavH,MAAQ,CAAChL,EAAUgB,EAAMwR,IAAU9P,QAAQ2E,UAAU1D,MAAK,IAAM3D,EAASyS,MAAMD,EAAOxR,KACnGuR,EAAaG,KAAO,CAAC1S,EAAUgB,EAAMwR,IAAUlL,qBAAoB,IAAMtH,EAASyS,MAAMD,EAAOxR,KAsR/F,MAAM2R,EAAc,CAChB1R,IAAI2R,EAAcjU,GAAiB4C,QAAEA,EAAOpD,MAAEA,EAAKmL,QAAEA,EAAOhF,YAAEA,IAC1D,IAAKrG,MAAMD,QAAQsG,GAAc,MAAM,IAAInD,MAAM,mCACjD,IAAKlD,MAAMD,QAAQ4U,GAAe,MAAM,IAAIzR,MAAM,oCAElD,GADAmI,EAAQuJ,cAAgBvO,EAAY,GAChCsO,EAAa/M,OAAMpI,GAAKA,aAAaqL,OAAO,CAC5C,MAAMgK,EAAU,GAChBxO,EAAYjE,OAAO,EAAGiE,EAAYG,UAAWmO,EAAazP,KAAI,CAAC2C,EAAMiN,KACjE,MAAMlK,EAAMmK,EAAUlN,GAUtB,OATiB,GAAbiN,EACIzJ,EAAQuJ,gBAAkBhK,IAC1BS,EAAQuJ,cAAgBhK,EACxBS,EAAQ0B,MAAMnC,IAEXvE,EAAYyO,KAAelK,GAClCiK,EAAQnC,IAAI,GAAG3F,MAAMnC,GAEzBiK,EAAQ3S,KAAK0I,GACNA,MACP1F,KAAIwH,IAAMrG,EAAY/D,MAAK0S,GAAMA,IAAOtI,KAAM/B,EAAE+B,GAAG/J,SAAQ,IAC3E,MACY0D,EAAYjE,OAAO,EAAGiE,EAAYG,UAAWmO,EAAazP,KAAI1F,IAC1D,MAAMoL,EAAMmK,EAAUvV,GAEtB,OADA6L,EAAQ4J,OAAOrK,GACRA,MACP1F,KAAIwH,GAAK/B,EAAE+B,GAAG/J,WAEzB,GA4EL,SAASuS,EAASC,EAASC,GACvB,KAAMA,EAAU5L,MAAM4K,qBAAqBtU,GAAU,OAAOqV,EAC5D,IAAIrS,EAAQsS,EAAU5L,MAAM4K,UAC5B,MAAMxJ,EAAM5K,MAAMD,QAAQ+C,EAAM5C,OAAS,IAAI8M,iBAAqBmI,EAKlE,GAJAC,EAAUxK,IAAMA,EAEZ5K,MAAMD,QAAQ+C,EAAM5C,QAAQ0K,EAAIuG,OAAOgE,KAErCA,aAAmB7J,MAAO,MAAM,IAAIpI,MAAM,0CAGhD,IAAImD,EAAc,GAIlB,OAFAiO,EAAavH,OAAM,IAvFvB,SAA2BjK,EAAOqS,EAASvK,EAAKvE,GAC5C,MAAMS,EAAShE,EAAMpB,UAAS,CAACiT,EAAcjU,GAAmB4C,UAASpD,WAAUmE,MAG/E,GAFA3D,aAA2BmK,MAAQ8J,IAAiBjU,GAAmBA,EAAgBiC,SAAQ,GAE3FgS,aAAwB9J,KACxBxE,EAAYjE,OAAO,EAAGiE,EAAYG,QAAQtB,KAAIgL,GAAMA,aAAcrF,MAAQqF,EAAGvN,YAC7EwS,EAAQlL,KAAO,GACfqK,EAAaG,MAAK,IAAMU,EAAQpI,MAAM4H,KACtCtO,EAAYnE,KAAKyS,QAGjB,GADAQ,EAAQlL,KAAO0K,EACX3U,MAAMD,QAAQ4U,GAAe,CAC7BQ,EAAQlL,KAAO,GACf,MAAMlH,EAAO,CAAC4R,EAAcjU,EAAiB,IAAK2D,EAAQf,UAASpD,QAAOmG,cAAagF,QAAS8J,IAChGb,EAAavH,OAAM,KACX2H,EAAYpR,aAAoBxB,SAChC4S,EAAYpR,MAAYP,GAExB2R,EAAY1R,OAAOD,EACtB,GAErB,MAAmB,GAAI4R,aAAwBrE,EAAa,CAC5C6E,EAAQlL,KAAO,GAGf5D,EAAYjE,OAAO,EAAGiE,EAAYG,QAAQtB,KAAIgL,GAAMA,aAAcrF,MAAQqF,EAAGvN,YAE7E,MAAMuN,EAAK6E,EAAUJ,GACrBtO,EAAYnE,KAAKgO,GACjBA,EAAGhD,WAAU,IAAM7G,EAAYG,QAAUM,MACzC,IAAIuO,GAAW,EACf,MAAMC,EAAW,CAACC,EAAOC,EAAUC,GAAW,OACtCJ,GAAaI,MACbF,EAAMzI,aACNyI,EAAMxI,MAAMyI,GACZH,GAAW,GACJ,GAKTK,EAAY,KAEd,GADAJ,EAASH,EAASjF,IACbmF,EAAU,OAAOhM,oBAAoBqM,EAAS,EAEvDrM,oBAAoBqM,GACpBP,EAAQlK,aAAa0K,IACjB,GAAIA,aAAa9K,MAAQsK,EAAQrI,aAAe6I,EAE5C,OADAA,EAAExE,OAAOgE,GACFG,EAASH,EAASjF,GAAI,GAEjCoF,EAASH,EAASjF,EAAG,GAEzC,MAAmB,GAA2B,iBAAhByE,EACd,IACIQ,EAAQlL,KAAO2L,KAAKC,UAAUlB,EAAc,KAAM,GACnC,CAAjB,MAAOmB,GAAU,CAG3B,MAAO,CAACrT,GAAU,KACd0S,EAAQlL,KAAO,GACf5D,EAAYnB,KAAI0F,GAAOA,EAAIjI,QAAQF,KAC/B/B,aAA2BmK,MAC3BnK,EAAgBiC,UAEhBF,IACA0S,EAAQrO,SACRhE,EAAMH,SAAQ,GACjB,CACJ,IACF,GAEHgI,EAAEC,GAAKhJ,UAAUkF,EACrB,CAc6BiP,CAAkBjT,EAAOqS,EAASvK,EAAKvE,KAEzDuE,CACX,CAgHA,MAAMoL,EAAoB,CAAC,QAAS,QAe7B,SAASC,EAAOC,EAASC,EAAYC,SAASC,MAEjD,GADwB,iBAAbF,IAAuBA,EAAYC,SAASE,cAAcH,MAC/DA,aAAqBtL,MAAO,MAAM,IAAI3H,MAAM,oCAClD,IAAIqT,EACJ,MAAMC,EAdV,SAAuBL,GACnB,KAAMA,aAAqBtL,MAAO,MAAM,IAAI3H,MAAM,oCAClD,MAAMsT,EAAS,IAAIlL,KAAK,IAMxB,OALI6K,EAAUM,WACVN,EAAUM,WAAWtF,OAAOqF,GAE5BL,EAAUhF,OAAOqF,GAEdA,CACX,CAKmBE,CAAcP,GAC7B,SAASQ,EAAY/L,GACjB,GAAI5K,MAAMD,QAAQ6K,GAEd,OADA2L,EAAY3L,EAAI1F,KAAI6O,GAASkC,EAAOlC,EAAOoC,KACpCI,EAIX5L,EAAEwL,GAAWvU,UAAU+I,EAAEC,GAAKhJ,WAG1B4U,EAAOzJ,MAAMnC,GAGbD,EAAEC,GAAKM,kBAAkBiL,GAI7BK,EAAO1P,SACPyP,EAAY3L,CACf,CAQD,GA9CmB,EAACsL,EAASC,MACzBH,EAAkBtH,SAAStO,OAAO8V,GAAS1Q,MAAMoR,kBACjDZ,EAAkBtH,SAASyH,EAAUtF,iBAAzC,EA4CIgG,CAAeX,EAASC,GAAY,CAEpCQ,EADY5B,EAAUmB,GAEzB,CACD,OAXAY,iBACI,GAAIP,EAAW,OAAOA,EACtB,KAAMJ,aAAqBtL,MAAO,MAAM,IAAI3H,MAAM,2CAGlD,OADAyT,QADkBrC,EAAavH,OAAM,IAAMgI,EAAUmB,MAE9CK,CACV,CAKMQ,EACX,CAEO,SAAShC,EAAUiC,GACtB,GAAIA,aAAiB1G,GAAe0G,EAAMpM,eAAeC,KACrD,MAAM,IAAI3H,MAAM,4FAEpB,GAAIlD,MAAMD,QAAQiX,GAEd,OAAOA,EAAMC,KAAKC,KAAUhS,KAAI6O,GAASgB,EAAUhB,KAC5CiD,aAAiBlV,SACxBkV,EAAQ,IAAIlD,EAAekD,EAAO,CAAE/F,SAAU,KACrC+F,aAAiBG,aAAkBH,aAAiB1G,IAC7D0G,EAAQ,IAAI9C,EAAY8C,IAE5B,MAAMpM,EA7jBV,SAAuBoM,GACnB,MAAMI,EAAiBC,GAASA,EAAKJ,KAAKC,KAAUhS,KAAI6O,GAASgB,EAAUhB,KAC3E,GAAIiD,aAAiBnM,KAAM,OAAOmM,EAClC,GAAIA,aAAiB1G,GAAe0G,EAAMpM,eAAeC,KAAM,OAAOmM,EAAMpM,IAC5E,GAAIoM,aAAiB/C,EACjB,OAAOmD,EAAcJ,EAAMxN,MAAMyH,UAErC,GAAI+F,aAAiB9C,EACjB,OAAIlU,MAAMD,QAAQiX,EAAMxN,MAAM4K,WACnBgD,EAAcJ,EAAMxN,MAAM4K,WAE9B4C,EAAMxN,MAAM4K,qBAAqBvJ,KAAOmM,EAAMxN,MAAM4K,UAAY,IAAI9I,KAAK0L,EAAMxN,MAAM4K,WAEhG,GAAI4C,aAAiBlD,EAAgB,CACjC,GAAIkD,EAAMjH,WAAWiH,EAAMxR,gBAAiB1D,SAAU,CAClD,MAAMwV,EAAYN,EAAMjH,WAAWiH,EAAMxR,MACzCwR,EAAMxR,KAAO8R,CAChB,CACD,GAAIN,EAAMxR,gBAAgB1D,SAAU,CAChC,IAAI0H,EAAQwN,EAAMxN,MAGlB,MAFsC,iBAA3BwN,EAAMxR,KAAK+R,eAA0B/N,EAAQ,IAAKwN,EAAMxR,KAAK+R,gBAAiB/N,IAElFuL,EADIiC,EAAMxR,KAAKgE,GAEzB,CACD,OAAO4M,SAASoB,cAAcR,EAAMxR,KACvC,CACD,GAAIxF,MAAMD,QAAQiX,GACd,OAAOI,EAAcJ,GAEzB,GAAIA,aAAiBlV,SAAU,CAC3B,IAAI0H,EAAQ,CAAEyH,SAAU,IAExB,MADiC,iBAAtB+F,EAAMO,eAA0B/N,EAAQ,IAAKwN,EAAMO,aAActG,SAAU,KAC/E8D,EAAUiC,EAAMxN,GAC1B,CACD,GAAIwN,aAAiBlX,EACjB,OAAOiV,EAAU,IAAIb,EAAY8C,EAAO,IAAInI,IAEhD,IACI,OAAO,IAAIvD,KAAKsK,KAAKC,UAAUmB,GAGlC,CAFC,MAAOlB,GACL,OAAO,IAAIxK,KAAK0L,EACnB,CACL,CAmhBgBQ,CAAcR,GACtBA,aAAiB1G,GAAe1F,aAAeC,QAAUD,EAAIoM,iBAAiB1G,IAC9EjP,OAAO0C,eAAe6G,EAAK,QAAS,CAChC5G,IAAK,IAAMgT,IAkCnB,GAAIhX,MAAMD,QAAQ6K,GAAM,CACpB,GAAIoM,EAAMrD,kBAAkBrD,EACxB,OAAO1F,EAEX,MAAM6M,EAAM,IAAIzK,iBAKhB,OADAyK,EAAItG,UAAUvG,GACP6M,CACV,CACD,MAzCoB,CAACC,IAGjB,GAAIV,aAAiBnM,KAAM,OAAO6M,EAClC,GAAIV,aAAiB9C,GAAepU,EAAQH,QAAQqX,EAAMxN,MAAM4K,WAAY,OAAOc,EAASwC,EAAUV,GACtG,GAAIA,GAASA,EAAMxR,gBAAgB1D,SAAU,OAAO4V,EACpD,MAAMC,EAAU,GAChB,GAAIX,aAAiB1G,EAAa,CAE9B,GADA0G,EAAMpM,IAAM8M,GACPV,EAAMxN,MAAMyH,SAAU,OAAOyG,EAClCC,EAAQzV,QAAQ8U,EAAMxN,MAAMyH,SAASgG,KAAKC,KAAUhS,KAAI6O,IACrB,iBAApBiD,EAAMjH,aACbU,QAAQC,KAAK,wCACbsG,EAAMjH,WAAa,CAAE,GAErBgE,aAAiBzD,IACjByD,EAAMJ,OAASqD,EACf3V,OAAO6C,OAAO6P,EAAMxD,WAAYyG,EAAMzG,YACtCwD,EAAMhE,WAAaiH,EAAMjH,YAEtBkG,EAAOlC,EAAO2D,MAE5B,CAMD,OALAjT,QAAQmT,IAAID,GACPjS,MAAMuL,KAjjBnB,SAAmBrG,EAAKoM,GACpB,KAAMpM,aAAeC,MAAO,MAAM,IAAI3H,MAAM,iCAC5C,KAAM0H,aAAeiN,aAAc,OAAO,KAC1C,GAAIb,GAASA,EAAMxR,gBAAgB1D,SAAU,OAAO,KACpD,KAAMkV,aAAiBlD,GAAiB,OAAO,KAC/C,MAAMgE,EAAa,CAAE,EACfC,EAAc,CAAE,EAEhBC,EAAkB,CAACxO,GAAQmC,EAAUwE,GAAYvF,EAAKqN,EAAgB,MACxE,MAAMpM,EAAe,CAAC3L,EAAOgY,EAAQtN,EAAKuN,EAAQxM,KAC9C,IAAI,QAAQsH,KAAKkF,GAAjB,CACA,GAAID,aAAiBE,mBAAqB,CAAC,YAAa1J,SAASyJ,GAC7DD,EAAMG,UAAW,MAEjB,IAAI,CAAC,WAAY,UAAU3J,SAASyJ,GAGhC,OAAOD,EAAMC,GAAmB,KAAVjY,GAAsBA,EACzC,GAAKiY,KAASD,GAAW,CAAC,SAAU,YAAYxJ,gBAAgBxO,GACnE,MAAoB,iBAATA,GAA4C,iBAAhBgY,EAAMC,GAA2B9W,OAAO6C,OAAOgU,EAAMC,GAAQjY,GAC7FgY,EAAMC,GAASjY,CACzB,CACLgY,EAAMrM,aAAasM,EAAOjY,EAZD,CAYO,EAE9BoY,EAAU,CAACpI,EAAIvE,EAAUwE,KAC3B,MAAMlL,EAAU,GAEhB,OADA+S,EAAgBxO,EAAO,CAACmC,EAAUwE,GAAYD,EAAIjL,GAC3C,IAAMqP,GAAa,IAAMrP,EAAQC,KAAI3C,GAAMA,aAAcT,UAAYS,OAAW,EAErFgW,EAAgB,CAAC1T,EAAQ2T,KAC3B,MAAMC,EAAevY,IACbA,aAAiBJ,EAEjB6K,EAAEC,GAAKhJ,UAAU1B,EAAMwB,UAAS,CAAC8C,EAAKkU,KAClC7T,EAAOL,EAAKkU,GACL,IAAMxY,EAAMyC,aACpB,IAEHkC,EAAO3E,EACV,EAEDF,MAAMD,QAAQoQ,GACdA,EAAUjL,KAAIV,GAAOiU,EAAYjU,KAEjCiU,EAAYtI,GAEhBxF,EAAEC,GAAKhJ,WAAU,IAAM4W,aAAoB1W,UAAY0W,KAAW,EAEhEG,EAAU,IAAM,KACtB,IACIC,EADAvH,EAAUsH,EAEd,MAAME,EAAU1I,EAEV2I,EAAM,kBAAkBnJ,KAAKhE,GAEnC,GADImN,IAAOnN,EAAWmN,EAAI,IACV,YAAZnN,KAA4BqL,aAAiBlD,GAAiB,OAAOtK,EACzE,GAAuB,iBAAZmC,EAAsB,OAAOnC,EAExC,GAAImC,IAAaA,EAAS/B,WAAW,OAAS+B,EAAS/B,WAAW,MAAO,CAErE,IAAIpE,EAAOmG,EAAS1I,MAAM0I,EAAS/B,WAAW,MAAQ,EAAI,GAAGgN,cACzDpR,EAAKoN,QAAQ,MAAQ,IACrBpN,EAAOA,EAAKvC,MAAM,EAAGuC,EAAKoN,QAAQ,OAEtC,MAAMmG,EAAgB,CAACxW,EAAIQ,EAAO,MAC1BR,aAAczC,IACdyC,EAAKA,EAAG5B,YAAc,IAAM,KAAO4B,EAAGrC,OAEnCqC,KAAMQ,IAEXhB,EAAW,IAAIgB,KACjB,GAAI/C,MAAMD,QAAQoQ,GACd,OAAOA,EAAUjL,KAAI3C,GAAMwW,EAAcxW,EAAIQ,KAEjDgW,EAAc5I,EAAWpN,EAAK,EAElC,IAAIiW,EAAW,IAAMpO,EAAIgC,oBAAoBpH,EAAMzD,GAKnD,OAJA4I,EAAEC,GAAKhJ,UAAUoX,GAEjBpO,EAAI+B,iBAAiBnH,EAAMzD,GAC3BsP,EAAU,IAAM2H,EACTxP,CACV,CAAM,GAAmB,KAAfmC,EAAS,GAAW,CAC3B,MAAM/H,EAAWgH,EAAIe,EAAS1I,MAAM,IAGpC,OAFA2H,EAAIe,EAAS1I,MAAM,IAAMkN,EACzBkB,EAAU,IAAMzG,EAAIe,EAAS1I,MAAM,IAAMW,EAClC4F,CACV,CAAM,GAAIoP,EAAY,2HAA2HjJ,KAAKhE,GAAW,CAC9J,MAAMgD,KAAEA,EAAInL,IAAEA,EAAG6M,UAAEA,GAAcuI,EAAU9I,OAE3C,GADAiI,EAAYpJ,GAAQA,KAAQoJ,EAAcA,EAAYpJ,GAAQ,EAAI,EAC9DqI,EAAMzG,WAAW5B,aAAiB7M,SAAU,CAC5C,IAAIkE,EAAQ+R,EAAYpJ,IACG,CAAC,QACQD,SAASC,GAAQ2F,EAAeA,EAAavH,QACxE,KACA+K,EAAWnJ,KAAOmJ,EAAWnJ,GAAQ,CAAE,GAC5C,MAAMsK,EAAMjC,EAAMzG,WAAW5B,GAAM,CAC/B9C,aAAcyM,EACdR,aACA7N,KAAM6N,EAAWnJ,GACjBuB,GAAItF,EAAKe,WAAUwE,YACnBnK,MAAOA,EAAQkT,OAAOlT,GAAS,EAC/BoK,cAAezB,EAAMnL,MACrB6M,UAAWA,GAAWpB,MAAM,KAAKxF,QAAO,CAACQ,EAAMkP,KAAYlP,EAAKkP,IAAS,EAAalP,IAAQ,CAAE,IAAK,CAAE,IAEvGgP,aAAenX,WAEf6I,EAAEC,GAAKhJ,UAAUqX,GACjB5H,EAAU4H,EACVhB,EAAc/V,KAAKmP,GACtB,GAER,CACD,OAAO7H,CACnB,CAAe,GAAI,CAAC,QAAS,SAAU,YAAYkF,SAAS9D,EAAIiG,YAAc,CAAC,QAAS,WAAWnC,SAAS/C,IAAckN,aAAmB/Y,EAAU,CACvI,CAAC,UAAU4O,SAAS9D,EAAIiG,YAAcjG,aAAewN,oBACrDxN,EAAI1K,MAAQ2Y,EAAQ3Y,MAEpByK,EAAEC,GAAKG,SAAQ,KACXH,EAAIwO,eAAiB,EACrB,IAAI/W,GAAK,EACT,IAAK,IAAIgX,KAAOzO,EACZvI,IACIgX,EAAInZ,QAAU2Y,EAAQ3Y,QACtB0K,EAAIwO,cAAgB/W,EAE3B,KAIT,MAAM4W,EAAOvM,GAAM4H,EAAavH,OAAM,IAE9B,CAAC,YAAY2B,SAAShC,EAAE4M,OAAO9T,MACxBqT,EAAQ7V,IAAI0J,EAAE4M,OAAOC,SAEzBV,EAAQ7V,IAAI0J,EAAE4M,OAAO3N,MAEhCf,EAAI+B,iBAAiB,QAASsM,GAC9B5H,EAAU,KACNzG,EAAIgC,oBAAoB,QAASqM,GACjCrO,EAAI1K,MAAQ,EAAE,EAGlByK,EAAEC,GAAKhJ,UAAUyP,EAC7B,KAAe,IAAgB,SAAZ1F,GAAuB,cAAcsH,KAAKtH,GAAW,CAC5D,MAAM6N,EAAe5O,EAAIoB,MAAMyN,QACzBC,EAAaxZ,GAAUoU,EAAavH,OAAM,KACxC7M,aAAiBmB,OACjBA,OAAO6C,OAAO0G,EAAIoB,MAAO9L,GAEzB0K,EAAIoB,MAAMyN,SAAWvZ,CACxB,IAGL,OADAqY,EAAcmB,GAAW,IAAMA,EAAUF,KAClChQ,CACnB,CAAe,GAAgB,SAAZmC,GAAuB,gBAAgBsH,KAAKtH,GAAW,CAC9D,MAAM6N,EAAe5O,EAAIkB,aAAa,SAEhC6N,EAAY,CAACzZ,EAAO0D,IAAa0Q,EAAavH,OAAM,KACtD,MAAM6M,EAAYC,GAAWzZ,OAAOyZ,GAAQ5K,MAAM,KAAK/J,KAAIV,GAAOA,GAAOoG,EAAIwB,UAAUzI,IAAIa,KACrFsV,EAAeD,GAAWzZ,OAAOyZ,GAAQ5K,MAAM,KAAK/J,KAAIV,GAAOA,GAAOoG,EAAIwB,UAAUtF,OAAOtC,KACjGxE,MAAMD,QAAQ6D,GAAYA,EAASsB,KAAIV,GAAOsV,EAAYtV,KAAQsV,EAAYlW,GAC9E5D,MAAMD,QAAQG,GAASA,EAAMgF,KAAIV,GAAOoV,EAASpV,KAAQoV,EAAS1Z,EAAM,IAG5E,OADAqY,EAAcoB,GAAW,IAAMA,EAAUH,KAClChQ,CACV,CAAM,GAAImC,GAAYA,EAAS/B,WAAW,KAAM,CAE7C,GADA+B,EAAW,mBAAmBsH,KAAKtH,GAAYA,EAAS1I,MAAM,EAAG0I,EAASiH,QAAQ,MAAQjH,GACrFwE,EAAW,OAAO3G,EACvB,IAAIuQ,EACJ,MAAMC,EAAc9Z,IAChB,MAAM+Z,EAAaza,GAAM8Y,EAAQ1N,EAAKe,EAAS1I,MAAM,GAAIzD,GACzD,GAAwB,iBAAb2Q,EAkBP,OAAO8J,EAAU/Z,GAlBa,CAC9B,MAAMga,KAAEA,EAAMha,MAAOsE,GAAQtE,EAC7B,GAAIga,aAAgBpa,EAAS,CACzB,IAAIqa,EACJ,OAAOD,EAAKxY,UAAUgQ,IACdA,EACKyI,IAAMA,EAAOF,EAAUzV,aAAe1E,EAAU0E,EAAIR,MAAQQ,KAE7D2V,GAAMA,IACVA,EAAO,MAEJ,IAAMA,GAAQA,OACtB,EAC3B,CAEwB,GAAID,EAAM,OAAOD,EAAUzV,EAEnD,CAEiB,EAED2L,aAAqBrQ,IAGrBia,EAAUC,EAAW7J,IAGzB,MAAM8I,EAAM,IAAMc,IAMlB,OALId,aAAenX,WACf8I,EAAIsC,UAAU+L,GACd5H,EAAU4H,EACVhB,EAAc/V,KAAKmP,IAEhB7H,CACV,EACD,GAAI2G,aAAqBrQ,EAAS,CAC9B,MAAMgD,EAAQqN,EACRiK,EAAQtX,EAAMpB,UAASlC,IACzBqM,EAAarM,GACN,KACHsD,EAAMH,SAAQ,GACdiI,EAAIyP,gBAAgB1O,EAAS,KAIrChB,EAAEC,GAAKhJ,UAAUwY,GACjBjK,EAAYA,EAAUjQ,MACtB+X,EAAc/V,KAAKkY,EACtB,CASD,OAPAvO,EAAasE,GACTkB,IAAYsH,IACZtH,EAAU,KACNzG,EAAIyP,gBAAgB1O,EAAS,GAGrCsM,EAAc/V,KAAKmP,GACZ7H,GAEXnI,OAAOiE,QAAQ0R,EAAMxN,OAAOC,QAAO,CAACD,GAAQmC,EAAUwE,KAAe6H,EAAgBxO,EAAO,CAACmC,EAAUwE,GAAYvF,IAAM,GAC7H,CA0UgB2H,CAAUmF,EAAUV,GACpB1C,EAAavH,OAAM,IAAMpC,EAAE+M,GAAU1M,cAAc0M,EAAUzG,IAAU,IAExEyG,GAaJ4C,CAAY1P,EACvB,CCvnBO,SAAS0M,EAAUvV,EAAUsC,EAAS,CAAEkT,aAAc,CAAE,IAC3D,GAAkB,iBAARlT,EAAkB,MAAM,IAAInB,MAAM,uCAC5C,MAAMqU,EAAalT,EAAOkT,cAAc,CAAE,EAC1C,GAAwB,iBAAdA,EAAwB,MAAM,IAAIrU,MAAM,oDAClD,MAAMX,EAAIiH,GAAUzH,EAASwH,EAAS,IAAIgO,KAAgB/N,KAE1D,OADAjH,EAAGgV,aAAaA,EACThV,CACX,CCNA,MAAMgY,EAAW,IAAI7P,QACf8P,EAAQ,CACZjD,aAAa,CAAE,EACfd,WAAW,MAEN,SAASgE,EAAOC,EAASC,EAAgBtW,EAASmW,GACrD,MAAMjD,aAAEA,EAAeiD,EAAQjD,aAAYd,WAAEA,EAAa+D,EAAQ/D,YAChEpS,EACIuW,EAAe,cAAc/C,YACtBgD,gCACT,OAAOxZ,OAAO+Q,KAAKmF,EACpB,CACDuD,yBAAyBnM,EAAMoM,EAAMC,GACnC,MAAMxR,EAAQ+Q,EAASvW,IAAI/D,MAAMuJ,MAE/BxE,EAASrF,QAAQ6J,EAAMmF,KACvBnF,EAAMmF,GAAMxO,YAAc6a,GACE,iBAArBxR,EAAMmF,GAAMzO,QAEnBsJ,EAAMmF,GAAM3L,IAAIgY,GAChBvK,QAAQ4D,IAAI1F,EAAMqM,GAErB,CACDnX,YAAYoX,GACVnX,QACAmX,EAA0B,iBAAVA,GAAsBA,EAASA,EAAS,CAAA,EACxD,MAAM5Q,EAAQ,CACZ6Q,kBAAmB9Q,IACnB+Q,qBAAsB/Q,IACtBgR,gBAAiBhR,IACjBxI,UAAW,CAAC,QACZyZ,QAASjR,EAAS,CAChBF,YAAc3H,GACL,IAAIiB,KACT,MAAM8X,EAAK/Y,EAAGiB,GACV8X,aAAcxZ,UAChB7B,KAAK2B,UAAU0Z,EAChB,IAIP9R,MAAOyR,EACPhK,SAAU,IAEZsJ,EAASvX,IAAI/C,KAAMoK,GACnBM,EAAE1K,MACCD,MAAMD,QAAQkb,EAAOhK,WACtB5G,EAAQ4G,SAAS/O,QAAQ+Y,EAAOhK,UAElC,MAAM1F,EAAOlH,EAAOoS,WAChBxW,KAAK8Q,aAAa,CAChBC,KAAM,WAAa3M,EAAOoS,YAAYzF,KAAO,SAAW,OACxDuK,iBAAkBlX,EAAOoS,YAAY8E,eACrCC,eACE,WAAanX,EAAOoS,YAAY+E,eAC5B,SACA,UAERvb,KACF0K,EAAEY,GACJ,MAAMkQ,EAAapa,OAAOC,OAAO,CAC/BiK,OACA2E,GAAIjQ,QACDoB,OAAOiE,QAAQ+E,GAASZ,QAAO,CAACiS,GAAKxT,EAAG1I,MACrCQ,MAAMD,QAAQP,KAChBkc,EAAGxT,GAAK1I,EAAE,IAELkc,IACN,MAELC,YAAW,KACTlX,QAAQ2E,UAAU1D,MAAK,KACrB,IAAK,IAAIrD,KAAKpC,KAAK8L,WAAY,CAC3B,MAAM4C,EAAKtM,EAAEsM,KACZ3J,EAASrF,QAAQsb,EAAOtM,IACvBsM,EAAOtM,GAAM3L,IAAIX,EAAEnC,OAEnB+a,EAAOtM,GAAMtM,EAAEnC,KAEpB,CACDmK,EAAQb,MAAQD,EAAS,IAAKgO,KAAiB0D,IAC/C5Q,EAAQ4G,SAAS/O,QAAQjC,KAAKmL,YAC9B,MAAM8E,EAAKyK,EACT,IAAKtQ,EAAQb,MAAOyH,SAAS,IAAI5G,EAAQ4G,WACzCwK,GAGFlQ,EAAK4F,OAAO4D,EAAU7E,IACtB7F,EAAQgR,QAAQ,GAAGpb,MACfA,KAAKkN,aACP9C,EAAQ6Q,kBAAkB,IAC3B,GACD,GAEL,CACDA,oBACEX,EAASvW,IAAI/D,MAAMib,kBAAkB,IACtC,CACDC,uBACEZ,EAASvW,IAAI/D,MAAMkb,qBAAqB,IACzC,CACDC,kBACEb,EAASvW,IAAI/D,MAAMmb,gBAAgB,IACpC,GAIH,OADAQ,eAAenB,OAAOC,EAASE,EAAc,CAAE,GACvCpR,GAAU,IAAIoR,EAAa,CAAE3J,SAAU,MAAOzH,GAC1D,CC3GO,MAAMqS,EAAe,CAAC,OAAQ,OAAQ,KAAM,MAAO,QAAS,KAAM,MAAO,QAAS,SAAU,OAAQ,OAAQ,QAAS,SAAU,QAAS,OAClIC,EAAe,CAAC,IAAK,OAAQ,UAAW,OAAQ,UAAW,QAAS,QAAS,IAAK,OAAQ,MAAO,MAAO,aAAc,OAAQ,KAAM,SAAU,SAAU,UAAW,OAAQ,OAAQ,MAAO,WAAY,OAAQ,WAAY,KAAM,MAAO,UAAW,MAAO,SAAU,MAAO,MAAO,KAAM,KAAM,KAAM,QAAS,WAAY,aAAc,SAAU,OAAQ,SAAU,OAAQ,QAAS,WAAY,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OAAQ,SAAU,SAAU,KAAM,OAAQ,IAAK,SAAU,MAAO,QAAS,MAAO,MAAO,QAAS,SAAU,KAAM,OAAQ,OAAQ,MAAO,OAAQ,UAAW,OAAQ,OAAQ,QAAS,MAAO,WAAY,SAAU,KAAM,WAAY,SAAU,SAAU,IAAK,QAAS,UAAW,MAAO,WAAY,IAAK,KAAM,KAAM,OAAQ,IAAK,OAAQ,SAAU,UAAW,SAAU,OAAQ,QAAS,SAAU,OAAQ,SAAU,QAAS,MAAO,UAAW,MAAO,QAAS,QAAS,KAAM,WAAY,WAAY,QAAS,KAAM,QAAS,OAAQ,QAAS,KAAM,QAAS,IAAK,KAAM,MAAO,QAAS,OAI59BC,EAAoB,yOACpBC,EAA2B,0QAE3BC,EAA0B,kCAC1BC,EAAmB,oCAGnBC,EAAyB,8DACzBC,EAAuBvO,EAAuBqO,EAAkB,UAAW,WAG3EG,EAA6B,8DAC7BC,EAA2BzO,EAAuBqO,EAAkB,UAAW,WAG/EK,EAA0B,8DAC1BC,EAAwB3O,EAAuBqO,EAAkB,UAAW,WAG5EO,EAA8B,uEAI9BC,EAAanO,EACtB6N,EACAE,EACAE,EANqC3O,EAAuBqO,EAAkB,UAlBhD,oBA0B9B,OAQG,SAASS,EAAUC,GACtB,MAAMlN,EAASsM,EAAyBrM,KAAKiN,GAC7C,OAAKlN,GACEA,EAAOI,OAAO+M,aADD,IAExB,CAeO,SAASC,GAAgBC,GAG5B,MAAM7c,EAAQ,CAACwL,EAAMiD,EAAMzO,KACvB,MAAM8c,EAAY,CAACxY,EAAMtE,EAAO+c,EAAQtO,KACpC,GAAIjD,EAAKuR,GAAQ,CACb,IAAI5a,EAAIvB,KAAK+R,MAAsB,IAAhB/R,KAAKC,UACxB,KAAQkc,EAAQ,IAAI5a,OAASqJ,GAAQrJ,IAErC,OADAqJ,EAAKuR,EAAQ,IAAI5a,MAAQmC,EAClBkH,EAAKuR,EACf,CACD,OAAOzY,GAEX,OAAImK,EAAK/E,WAAW,MAAM+E,EAAK/E,WAAW,OAAO,CAAC,QAAQ,SAAS8E,SAASC,IAExD,mHAAmHgB,KAAKhB,GADjIqO,IAIJ9W,MAAMhG,GAASA,EAAQgZ,OAAOhZ,EAAK,EAE9C,OAAO6c,EAAW9N,MAAMyN,GAAYjT,QAAO,CAACiC,EAAMwD,KAC9C,GAAI,QAAQ+D,KAAK/D,GAAS,OAAOxD,EACjC,IAAIgE,EAYJ,OAXIA,EAASyM,EAAuBxM,KAAKT,MAE9BQ,EAAS2M,EAA2B1M,KAAKT,MAEzCQ,EAAS6M,EAAwB5M,KAAKT,MAEtCQ,EAAS+M,EAA4B9M,KAAKT,IALjDxD,EAAKgE,EAAOI,OAAOnE,UAAYzL,EAAMwL,EAAMgE,EAAOI,OAAOnE,SAAU+D,EAAOI,OAAOK,YAO1ET,EAASuM,EAAwBtM,KAAKT,MAC7CxD,EAAKgE,EAAOI,OAAOnE,UAAY,IAE5BD,IACR,GACP,CACO,SAASwR,GAAaN,GACzB,MAAMlN,EAASsM,EAAyBrM,KAAKiN,GAC7C,IAAKlN,EAAQ,OAAO,KACpB,MAAMlK,KAAEA,EAAIkG,KAAEA,EAAIyR,YAAEA,EAAWN,aAAEA,GAAiBnN,EAAOI,OACzD,MAAO,CACCsN,iBACA,OAAOvB,EAAanN,SAASzO,KAAKuF,KACrC,EACG6X,iBACA,OAAOvB,EAAapN,SAASzO,KAAKuF,KACrC,EACDA,OACAkG,OACAyR,cACAN,eACAD,UACApT,MAAOsT,GAAgBpN,EAAOI,OAAOpE,MACrC4R,SAASC,GACL,KAAMA,aAAkB1O,GAAc,MAAM,IAAI3L,MAAM,qCACtD,MAAMsa,EAAc3O,EAAYS,MAAMrP,KAAKuF,KAAM+X,GACjD,GAAIC,GAA2C,GAA5BA,EAAYtd,MAAMsG,QAA8C,KAA/BgX,EAAYtd,MAAM,GAAGwS,IAAI,IAAa8K,EAAYtd,MAAM,aAAc4B,SAItH,OAHA7B,KAAKuF,KAAOgY,EAAYtd,MAAM,GAAG+C,MAAM,GAAI,GAC3Csa,EAAOxN,WAAW9P,KAAKuF,MAAQgY,EAAYtd,MAAM,GAE1CD,KAAKuF,KAEhB,IAAIA,EAAOqJ,EAAYI,MAAMhP,KAAKuF,QAAUQ,WAAYuX,EAAOvX,KAS/D,OARAR,EAAuB,IAAhBA,EAAKgB,OAAehB,EAAK,GAAKA,EAAKqK,KAAK,IAC5B,iBAARrK,GAAmC,mBAARA,IAClCA,SAAiBA,EAAV,2BAMJvF,KAAKuF,KAAOA,CACtB,EAET,CCtIA,SAASiY,GAASC,EAAWC,EAAmBC,GAC5C,KAAOD,EAAkBnX,QAAQ,CAC7B,MAAM2N,EAAOwJ,EAAkBxW,QAC/B,IAAI,QAAQ8L,KAAKkB,GACjB,GAAIwI,EAAUxI,GAAO,CACjB,MAAM6C,EAAQkG,GAAa/I,GAC3B6C,EAAM/F,SAAW,GACjB+F,EAAMsG,SAASM,GDmIApY,EClICwR,EAAMxR,KDmIvBqW,EAAanN,SAASlJ,GAAMoR,kBCnIKI,EAAMmG,aAClCU,GAAY7G,EAAO2G,EAAmBC,GAE1C,MAAM1N,EAAK,IAAI4D,EAAekD,EAAMxR,KAAM,IAAKwR,EAAMxN,MAAOyH,SAAU+F,EAAM/F,UAAY2M,GACxFF,EAAUxb,KAAKgO,EAC3B,KAAe,CACH,MAAM4N,EAAQ3J,EAAKlF,MAAMV,EAAkBM,EAAYC,OAAQ,eAC3D,QAAQmE,KAAK6K,EAAM,KAAKA,EAAM3W,QAC9B,QAAQ8L,KAAK6K,EAAMpL,IAAI,KAAKoL,EAAM5W,MACtCwW,EAAUxb,QAAQ4b,EAAM5Y,KAAI6Y,IACxB,MAAMlU,EAAqB,iBAALkU,EAAiBlP,EAAYS,MAAMyO,EAAGH,GAAeG,EAE3E,GAAgB,iBADhBA,EAAIlU,EAAQA,EAAM3J,MAAM,GAAK6d,GACH,OAAOA,EACjC,MAAMC,EAAaC,GAAM,qBAAqBhL,KAAKgL,GACnD,OAAID,EAAUD,GACHA,EAAE9O,MAAM,wBAAwB/J,KAAI6Y,GAAIC,EAAUD,GAAK3H,SAAS8H,cAAc,yBAAyBvO,KAAKoO,GAAG,IAAKA,IAAGxW,QAAOwW,GAAKA,IAEvI,IAAI7J,EAAY6J,EAAGH,EAAW,IAE5C,CACJ,CD8GE,IAAoBpY,EC7GvB,OAAOkY,CACX,CACA,SAASG,GAAY7G,EAAO2G,EAAmBC,GAC3C,GAAI5G,EAAMxR,gBAAgB1D,WAAakV,EAAMxR,KAAKmJ,KAAM,OACxD,IAAIwP,EAAQ,EACZ,MAAMnY,EAAQ2X,EAAkB1X,WAAUyG,IACtC,MAAM0R,EAAMlB,GAAaxQ,GACnB2R,EAAQxP,EAAYS,MAAM8O,EAAMA,EAAI5Y,KAAOkH,EAAGkR,GACpD,SAAIQ,IAASC,GAASA,EAAMne,MAAM,KAAO8W,EAAMxR,MAAU4Y,EAAI5Y,OAASwR,EAAMxR,QACxE2Y,EAAQC,EAAIvB,aAAesB,EAAQ,EAAIA,EAAQ,EAC3CC,EAAIvB,cAAgBsB,GAAS,GAE9B,IAQX,IANe,IAAXnY,EACAgR,EAAM/F,SAAW0M,EAAkBvb,OAAO,EAAGub,EAAkBnX,QAAQe,QAAOmF,IAAM,QAAQuG,KAAKvG,MAEjGsK,EAAM/F,SAAW0M,EAAkBvb,OAAO,EAAG4D,EAAQ,GAAGuB,QAAOmF,IAAM,QAAQuG,KAAKvG,KAClFsK,EAAM/F,SAAS/J,OAED,UAAd8P,EAAMxR,KAAkB,CACxB,IAAI8Y,EAAYtH,EAAM/F,SAASpB,KAAK,IACpC,MAAMiJ,EAAMjK,EAAYS,MAAMgP,EAAWV,GACrC9E,IACAwF,EAAYxF,EAAIlJ,aAEpBoH,EAAM/F,SAAW,CAAC,IAAI3F,KAAKgT,GACnC,MACQtH,EAAM/F,SAAWwM,GAAS,GAAIzG,EAAM/F,SAAU2M,EAEtD,CAQA,SAASW,GAAgBC,EAAYjB,GACjC,KAAMA,aAAkB1O,GAAc,MAAM,IAAI3L,MAAM,qCACtD,MAAMub,EDlCH,SAA8BD,GACjC,OAAOA,EAAWvP,MAAM8M,EAC5B,CCgCsB2C,CAAqBF,GACjCG,EAAOlB,GAAS,GAAIgB,EAAWlB,GACrC,GAAmB,GAAfoB,EAAKnY,OAAa,CAClB,MAAM0J,EAAKyO,EAAK,GAChB,OAAOzO,aAAcI,EAAcJ,EAAK,IAAIgE,EAAYhE,EAAIqN,EAC/D,CAED,OADa,IAAItJ,EAAgB0K,EAAMpB,EAE3C,CAEO,SAASqB,GAASC,KAAYpP,GACjC,IAAIqP,EACkB,iBAAXrP,EAAK,KAA2C,IAAzBA,EAAK,GAAG,eACtCqP,EAASrP,EAAK,GACdA,EAAK,GAAK,IAEd,MAAOsP,GAzBX,SAAeF,KAAYtB,GACvB,MAAO,CAAC,IAAIA,EAAO9T,QAAO,CAAC4N,EAAM2H,EAAMhZ,KACnCqR,EAAKnV,KAAK2c,EAAQ7Y,GAAQ,qBAAqBA,iBAAqBuX,EAAOvX,YACpEqR,IACR,IAAKwH,EAAQtB,EAAO/W,SAASqJ,KAAK,IAAK0N,EAC9C,CAoByBjO,CAAMuP,KAAYpP,GAEjCwP,EAASV,GAAgBQ,EADhB,IAAIlQ,KAAeY,IAMlC,OAJIqP,IACIA,EAAO/O,YAA0C,iBAArB+O,EAAO/O,aAAwBkP,EAAOlP,WAAa+O,EAAO/O,YACtF+O,EAAOvO,YAA0C,iBAArBuO,EAAOvO,aAAwB0O,EAAO1O,WAAauO,EAAOvO,aAEvF0O,CACX,CCrFO,SAASN,MAAQ5b,GACpB,OAAOgS,EAAU6J,MAAY7b,GACjC,CACA,MAAMuR,GAAe,CAACvS,EAAUgB,EAAMwR,IAAUxS,EAASyS,MAAMD,EAAOxR,GACtEuR,GAAavH,MAAQ,CAAChL,EAAUgB,EAAMwR,IAAU9P,QAAQ2E,UAAU1D,MAAK,IAAM3D,EAASyS,MAAMD,EAAOxR,KACnGuR,GAAaG,KAAO,CAAC1S,EAAUgB,EAAMwR,IAAUlL,qBAAoB,IAAMtH,EAASyS,MAAMD,EAAOxR,KAIxF,SAASmc,GAAY1Z,EAAMgE,KAAUyH,GACxC,MAAMxB,EAAO,IAAI0P,4BAGjB,OAFA3V,EAAQA,GAAS,CAAEyH,SAAU,IAC7BA,EAAWA,EAAS/L,KAAI6O,GAASA,aAAiBqL,WAAarL,EAAQ,IAAIsL,WAAWtL,EAAOtE,KALhF,YAMTjK,EACO,IAAI8Z,eAAerO,EAAUxB,GANxB,QAQZjK,EACO,IAAI6Z,WAAWpO,EAAUxB,GAE7B,IAAI8P,cAAc/Z,EAAM,IAAKgE,EAAOyH,YAAYxB,EAC3D,CACAyP,GAAYM,SAdK,WAejBN,GAAY5T,KAdQ,OA4DpBqT,GAAKzZ,IA1CL,SAAapC,EAAOf,GAChB,MAAMsV,EAAKvU,aAAiBhD,EAAQ,IAAKgD,EAAW,OAAGA,EACvD,IAAKA,EAAMiC,GAAUC,EAASlC,GAAOtD,IACjC6X,EAAKjV,OAAO,EAAEiV,EAAK7Q,UAAUhH,GACtB6X,KAGX,MAAM9W,EAAc,CAACf,EAAG6C,IAAM,CAAC2C,EAASxF,GAAG,GAAIwF,EAAS3C,GAAG,IACrD8D,EAAW3G,GAAMuC,KAAYvC,EAAGsD,GAAO5C,IACzC,MAAO2H,EAAK7B,GAAOxG,EACnB,OAAOuF,EAASkC,KAAKjB,EAAM9F,EAAK,IAE9BkG,EAAYtD,EAAM5C,MAAMgF,IAAI3E,GAClC,IAAI8F,EAAciO,GAAavH,OAAM,IAAI3G,EAAUlB,IAAIiB,KACvD,MAAOG,EAAOC,GAAYvB,EAASqB,GA0BnC,OAzBAC,EAAM5E,UAAS2V,GAAM/C,GAAavH,OAAM,KACpC,KAAGsK,aAAgB5S,SACf4S,EAAKzP,OAAMC,GAAMA,aAAgBgD,QACjC,MAAM,IAAI3H,MAAM,kDACnB,MACF,GAKHJ,EAAMpB,UAAU8C,IACZ,GAAI4B,EAAUI,OAAShC,EAAIgC,OAAQ,CAC/B,MAAMC,EAAajC,EAAIgC,OACjBE,EAAMN,EAAUI,OACtBJ,EAAUhE,OAAOqE,EAAYC,GAAKxB,KAAIyB,GAAKA,EAAEzB,KAAI7C,GAAKA,EAAEM,SAAQ,OAChE4D,EAASnE,OAAOqE,EAAYC,EAC/B,MAAM,GAAIN,EAAUI,OAAShC,EAAIgC,OAAQ,CACtC,MAAMC,EAAaL,EAAUI,OAC7BJ,EAAUlE,QAAQsC,EAAIvB,MAAMwD,GAAYvB,IAAI3E,IAC5C6F,EAAUlB,KAAI,GAAIc,GAAQ3D,IAAM2D,EAAMhD,IAAIX,KAC1CkE,EAASrE,QAAQkE,EAAUnD,MAAMwD,GAAYvB,IAAIiB,GACpD,CAfgBC,EAAUlB,KAAI,EAAE1F,EAAG6C,GAAI2D,IAAUsO,GAAavH,OAAM,KAChE1K,EAAE1B,aAAa0B,EAAEW,IAAIgD,GACrBxG,EAAEmB,aAAanB,EAAEwD,IAAIF,EAAM5C,MAAM8F,GAAO,KAcrC,IAGLM,CACX"}