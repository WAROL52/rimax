const e=e=>e,t=Symbol("$$State"),n=(e=>"object"==typeof e&&t===e[".rxType"]).bind();class r{get isArray(){return Array.isArray(this.value)}toString(){return String(this.value)}valueOf(){return this.value}get".rxType"(){return t}static isState=n}function s(e,t){let n,s,a=!1,c=0;const u=Math.random(),l=[],f=new Set,d=new Set,p={};return Object.freeze(new class extends r{get guards(){return[...l]}get isDestroyed(){return a}get id(){return u}get len(){return{onChange:d.size,onCleanup:f.size,subscriber:c}}addGuard(e){if(!(e instanceof Function))return()=>{};const t=(...t)=>e(...t),n=l.push(t)-1;let r=!1;return()=>{if(r)return!0;if(l[n]===t)return l.splice(n,1),r=!0,!0;const e=l.find((e=>e===t));return e>-1&&(l.splice(e,1),!0)}}clear(e=!1){f.forEach((t=>t(e))),f.clear(),d.clear()}destroy(e=!0){a||(this.clear(e),a=!0)}onChange=((e,t=!1)=>{if(e instanceof r){const n=t instanceof Function?t:e=>e,r=e;let s;return c++,this.onChange(((...e)=>(r.set((()=>n(...e)),...e.slice(1)),()=>{s||(s=!0,c--)})),!0)}if(!(e instanceof Function))throw new Error("callback doit être une fonction");const n={dispatch:e,destroy:t?e(this.value,void 0,{methode:"set",value:this.value}):void 0},s=(...e)=>n.destroy=n.dispatch(...e);let o=!1;const i=(...e)=>{o||(o=!0,n.destroy instanceof Function&&n.destroy(...e),f.delete(i),d.delete(s))};return d.add(s),f.add(i),i}).bind();onCleanup=(e=>{if(!(e instanceof Function))throw new Error("callback doit être une fonction");return f.add(((...t)=>e(...t))),()=>f.delete(e)}).bind();get oldValue(){return s}constructor(e,t=(e=>e)){if(super(),Object.defineProperty(this,"value",{get:(()=>n).bind(),set:(e=>this.set(e)).bind(),enumerable:!0}),t&&"object"==typeof t&&(Object.assign(p,t.actions??{}),t=t.guard??(e=>e)),!(t instanceof Function))throw new Error("guard doit être une fonction");n=e,l.push(t);const c=(e,t=s,n={})=>{const r=[];return l.reduceRight(((e,s)=>(r.push(e),s(e,t,n,[...r]))),e)};e instanceof Promise||(n=c(e,void 0,{}));const u=(e=(()=>n),t=[],o=(e=>e))=>{if(!(e instanceof Function))throw new Error("callback doit être une function");if(a)throw new Error("cette Etat ne peut plus etre utiliser car elle est deja detruit");const c=t&&!Array.isArray(t)&&"object"==typeof t?t:{};if(t=Array.isArray(t)?t:c.dependencies??[],!Array.isArray(t))throw new Error("dependencies doit être une Array");const u=(t={})=>e(n,s,t),l={guard:o,...c},[f,d]=i(u(),l);l.guard!==o&&f.addGuard(o);const p=[this,...t].map((e=>{if(e instanceof r)return e.onChange(((e,t,n)=>(d(u(n),n),()=>!f.isDestroyed&&f.destroy(!0))))}));return f.onCleanup((()=>p.map((e=>e instanceof Function&&e())))),f};this.get=((e=(()=>this.value),t=[])=>u(e,t)).bind(),Object.entries(o).map((([e,t])=>this.get[e]=(e=(()=>this.value),n=[])=>u(e,n,t))),this.set=((e,t={methode:"set",value:e})=>{if(a)throw new Error("cette Etat ne peut plus etre utiliser car elle est deja detruit");if("object"!=typeof t)throw new Error("option doit être un object");if(e instanceof Promise)return e.then((e=>this.set(e)));e instanceof r&&(e=e.value),e instanceof Function&&(e=e(n,s));const o=n;return o!==e&&(e=c(e,o,t),s=o,n=e,(e=>{d.forEach((t=>t(n,s,e)))})(t)),n}).bind(),function(e,{createStateComputed:t}){const n=e,s=()=>{if(!n.isArray)throw new Error("pour pouvoir utiliser cette methode le type de state doit être une Array")},o=e=>{if(!(e instanceof Function))throw new Error("callback doit doit être une function")},a=e=>{if(e instanceof r&&(e=e.value),e instanceof Function&&(e=n.value.findIndex(e)),isNaN(e))throw new Error("index doit être une nombre ou une fonction qui retourne un nombre");return e};n.get.map=e=>{o(e);const t=(e,t)=>[i(e)[0],i(t)[0]],r=t=>e(...t,n),s=n.value.map(t);let a=s.map(r);const[c,u]=i(a),l=()=>s.map((([e,t],r)=>{t.isDestroyed||t.set(r),e.isDestroyed||e.set(n.value[r])}));return n.onChange((e=>{if(s.length>e.length){const t=e.length,n=s.length;s.splice(t,n).map((e=>e.map((e=>e.destroy(!0))))),u.splice(t,n)}else if(s.length<e.length){const n=s.length;s.push(...e.slice(n).map(t)),s.map((([,e],t)=>e.set(t))),u.push(...s.slice(n).map(r))}l()})),c},n.get.callback=e=>{if(!(e instanceof Function))throw new Error("callback doit être une function");return n.get((()=>e))};const c=(e,t)=>{if(s(),n.value[t]instanceof Function){const r=n.value[t](...e);return n.set([...n.value],{methode:"set",action:t,args:e,returnValue:r})}};n.set.splice=(...e)=>c([...e],"splice"),n.set.remove=(e,t=1)=>{const r=n.value.splice(e,t);return n.set([...n.value],{methode:"set",action:"remove",args:[e,t],returnValue:r})},n.set.edit=(e,t)=>{if(s(),(e=a(e))>-1){t instanceof Function&&(t=t(n.value[e],e,n.value));const r=n.value.splice(e,1,t);return n.set([...n.value],{methode:"set",action:"edit",args:[e,t],returnValue:r})}},n.set.push=(...e)=>c([...e],"push"),n.set.pop=()=>c([],"pop"),n.set.shift=()=>c([],"shift"),n.set.unshift=(...e)=>c([...e],"shift"),n.set.reverse=()=>c([],"reverse"),n.set.fill=(...e)=>c([...e],"fill"),n.set.filter=(e,...t)=>{s(),o(e);const r=n.value.filter(e,...t);return n.set(r,{methode:"set",action:"filter",args:[e,...t],returnValue:r})},n.set.slice=(...e)=>{s();const t=n.value.slice(...e);return n.set(t,{methode:"set",action:"slice",args:e,returnValue:t})},n.set.sort=(e=((e,t)=>t-e))=>{s(),o(e);const t=n.value.slice(),r=n.value.sort(e);return r.every(((e,n)=>e===t[n]))?n.value:n.set(r,{methode:"set",action:"sort",args:arguments,returnValue:r})},n.set.map=(e,t=n.value)=>{s(),o(e);const r=n.value.map(e,...args);return n.set(r,{methode:"set",action:"map",args:args,returnValue:r})}}(this,{createStateComputed:u}),Object.entries(p).map((([e,t])=>this.set[e]=e=>this.set(t instanceof Function?t(n,e):t))),e instanceof Promise&&e.then((e=>this.set(e)))}}(e,t))}const o={array(e){if(!Array.isArray(e))throw new Error("cette state doit être de type Array");return e},number(e){if("number"!=typeof e)throw new Error("cette state doit être de type Number");return e},string(e){if("string"!=typeof e)throw new Error("cette state doit être de type string");return e},function(e){if("function"!=typeof e)throw new Error("cette state doit être de type function");return e},boolean(e){if("boolean"!=typeof e)throw new Error("cette state doit être de type boolean");return e},symbol(e){if("symbol"!=typeof e)throw new Error("cette state doit être de type symbol");return e},object(e){if("object"!=typeof e)throw new Error("cette state doit être de type object");return e}};function i(t,n=e){return t instanceof r?n instanceof Function&&n!==e&&t.addGuard(n):Array.isArray(t)&&t[0]instanceof r&&t[1]===t[0].set?(t=t[0],n instanceof Function&&n!==e&&t.addGuard(n)):t=s(t,n),[t,t.set]}Object.entries(o).map((([e,t])=>i[e]=e=>i(e,t))),i.isState=n;const a=Symbol("$$ref");function c(e){const[t,n]=i(e),r=Object;return r.freeze(new class{constructor(){r.defineProperty(this,"current",{get:(()=>t.value).bind(),set:(e=>n(e)).bind(),enumerable:!0,configurable:!1}),r.defineProperty(this,"onChange",{value:(e=>t.onChange(e)).bind(),enumerable:!0})}onCleanup(e){return t.onCleanup(e)}destroy(e){return t.destroy(!0)}set(e){return n(e)}get".rxType"(){return a}})}function u(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const n=[];let s;const o=[...t],i=e=>e instanceof r?e.value:e;return o.forEach(((t,a)=>{t instanceof r&&n.push(t.onChange((()=>{(t=>{Promise.resolve().then((()=>s=e([...o.map(i)],t)))})(a)})))})),requestIdleCallback((()=>s=e([...o.map(i)],-1))),()=>{n.splice(0,n.length).map((e=>e?.())),s instanceof Function&&s(-1,[...o].map(i))}}function l(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const n=[];let s;const o=[...t],i=e=>e instanceof r?e.value:e,a=t=>s=e([...o.map(i)],t);return o.forEach(((e,t)=>{e instanceof r&&n.push(e.onChange((()=>{a(t)})))})),a(-1),()=>{n.splice(0,n.length).map((e=>e?.())),s instanceof Function&&s(-1,[...o].map(i))}}function f(e={}){if("object"!=typeof e)throw new Error("props doit être une object");return{...Object.entries(e).reduce(((e,[t,n])=>({...e,[t]:"children"===t||t.startsWith("$")||i.isState(n)?n:i(n)[0]})),{})}}c.isRef=(e=>"object"==typeof e&&a===e[".rxType"]).bind();const d={beforeDispatch:(...e)=>[...e],afterDispatch:(e,t)=>[e,t],onSubscribe:e=>e,clearAfterEachDispatch:!1};function p(e=d){if("object"!=typeof e)throw new Error("handler doit être un object");const{beforeDispatch:t=d.beforeDispatch,afterDispatch:n=d.afterDispatch,onSubscribe:r=d.onSubscribe,clearAfterEachDispatch:s=d.clearAfterEachDispatch}=e,o=new Set;return[e=>{if(!(e instanceof Function))throw new Error("callback doit être un function");return(e=r(e))instanceof Function&&o.add(e),()=>o.delete(e)},(e,...r)=>{const i=t(e,...r),a=o.forEach((e=>e?.(...Array.isArray(i)?i:[i])));return s&&o.clear(),n(e,a)}]}function h(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const n=[],[s,o]=i(),a=[...t],c=e=>e instanceof r?e.value:e,u=t=>o(e([...a.map(c)],t));return a.forEach(((e,t)=>{e instanceof r&&n.push(e.onChange((()=>{u(t)})))})),u(-1),s.onCleanup((()=>n.splice(0,n.length).map((e=>e?.())))),s}const m=new WeakMap;function y(e){if(!(e instanceof Node))throw new Error("dom doit etre un instance de Node");if(m.get(e))return m.get(e);let t=!1,n=[];const[s,o]=p({clearAfterEachDispatch:!0}),[i,a]=p({clearAfterEachDispatch:!0});let c=!1;s((()=>c=!0)),e.childNodes;const u=new Text,l=new Text;const f={getFiber:()=>null,attr:(t,n)=>e instanceof Element?t&&void 0!==n?(e.setAttribute(t,n||""),e.getAttribute(t)):t?e.getAttribute(t):e.attributes:null,style:(t,n)=>{if(e instanceof Element){if(void 0===n)return e.style[t];e.style[t]=n}return e.style[t]},addClass:t=>e instanceof Element&&e.classList.add(t),hasClass:t=>e instanceof Element&&e.classList.contains(t),removeClass:t=>e instanceof Element&&e.classList.remove(t),toggleClass:t=>e instanceof Element&&e.classList.toggle(t),on:(t,n)=>{const r=e=>n instanceof Function&&n(e);return e.addEventListener(t,r),()=>e.removeEventListener(t,r)},getFiber:()=>null,onConnected:i,dispatchConnected:a,onReady:s,dispatchReady:o,getTextRoot:()=>Promise.resolve().then((()=>(e.parentNode?(e.after(u),e.after(l)):l.parentNode&&l.after(u),u))),destroy:(r=!1)=>{e instanceof Node&&!(e instanceof DocumentFragment)&&e.remove(),t||(n.map((e=>e instanceof Function&&e(r))),t=!0,n=[],e instanceof Text&&r&&(e.data=""))},onCleanup:function(e){if((()=>{if(t)throw new Error("cette dom est deja considerer comme detruit, donc vous ne peux plus faire cette action...")})(),e instanceof r&&e.value instanceof Function){const t=e;e=(...e)=>{if(!(t.value instanceof Function))throw new Error("state.value doit etre une function");t.value(...e)}}else if(Array.isArray(e))return void e.map((e=>handler.onDestroy(e)));e instanceof Function&&n.push(e)},isReady:()=>c,isDestroyed:()=>t,isConnected:()=>isConnected,isCleaned:()=>isClean,get textRef(){return u},id:123};Object.freeze(f),f.onConnected((()=>{e.parentNode&&e.after(l)}));const d=setInterval((()=>{e.parentElement&&(clearInterval(d),a(e.parentElement))}),10);return m.set(e,f),f}const g={fr:{0:e=>""},en:{}},b=[];function v(...e){return new RegExp(`(?:${function(...e){return e.reduce(((e,t)=>new RegExp(e.source+function(e){return"string"==typeof e?e:e.source}(t))))}(...e).source})`)}function w(...e){return new RegExp(`(${function(...e){return e.reduce(((e,t)=>new RegExp(e.source+t.source)))}(...e).source})`)}function E(...e){return w(e.reduce(((e,t)=>new RegExp(e.source+"|"+t.source))))}!function({code:e,lang:t={fr:e=>"rxError",en:e=>"rxError"}}){if(b.includes(e))throw new Error("ce code is already used");if("object"!=typeof t)throw new Error("lang must be an object");b.push(e),Object.entries(t).map((([t,n])=>{g[t][e]=e=>{if(!(n instanceof Function))throw new Error("each value of lang must be a function");return n(e)}}))}({code:0,lang:{fr:e=>`rxError:${e}`,en:e=>`rxError:${e}`}});class x extends Array{static get regExp(){return/\(_\|-\[RXRefs\{index:\d+,type:[\w\$]+\}\]-\|_\)/}static get regExpSaved(){return/\(_\|-\[RXRefs\{index:(?<index>\d+),type:(?<type>[\w\$]+)\}\]-\|_\)/}static get regExpSavedG(){return/\(_\|-\[RXRefs\{index:(?<index>\d+),type:(?<type>[\w\$]+)\}\]-\|_\)/g}static{this.split=function(e="",t=!0){if("string"!=typeof e)throw new Error("chaine doit etre une chaine de caractere");const n=t?E(this.regExp):this.regExp;return e.split(n).reduce(((e,n)=>{if(!n)return e;const r=this.parse(n);return r&&t instanceof Function&&(n=t(r)),e.push(n),e}),[])},this.replaceAll=function(e,t=""){if("string"!=typeof e)throw new Error("chaine doit etre une chaine de caractere");return e.replaceAll(this.regExpSavedG,((e,n,r)=>t instanceof Function?t({input:e,index:n,type:r}):t))},this.parse=function(e="",t=null){if("string"!=typeof e)throw new Error("chaine doit etre une chaine de caractere");const n=/\(_\|-\[RXRefs\{index:(?<index>\d+),type:(?<type>[\w\$]+)\}\]-\|_\)/.exec(e),r=t?this.split(e,(({index:e})=>t[e])):null,s=r?r.join(""):"";return n?{index:n.groups.index,type:n.groups.type,input:n.input,value:r,valueString:s,refs:t}:null}}constructor(...e){super(),this.push(...e),this.components={}}}const A={},C={el:null,attrName:"",attrValue:"",directiveName:"",arg:"",modifiers:{},index:0};class j{#e={...A};get components(){return this.#e}set components(e){Object.assign(this.#e,e)}refs=new x;directives={$onInit({attrValue:e,el:t}=C){(e=e instanceof r?e.value:e)instanceof Function?y(t).onCleanup=e(t):console.warn("$onInit.attrValue doit être de type Function")},$shadowRoot({attrValue:e,el:t,arg:n}=C){const s=["article","aside","blockquote","body","div","footer","h1","h2","h3","h4","h5","h6","header","main","nav","p","section","span"];if(s.includes(t.localName)||t.localName.includes("-")){let s;e instanceof r&&(e=e.value),e instanceof Function&&(s=e);const o=[...t.childNodes],i=t.attachShadow({mode:"closed"===n?"closed":"open"}),a=s instanceof Function?s({el:t,root:i,children:o}):o,c=Array.isArray(a)?a:[a];t.innerHTML="",i.append(...c)}else console.warn(`l'element ${t.localName} ne suporte pas le attachShadow. Seule les element personnalisé (balise avec un tiré) et quelque element native le supporte,\n                voici une liste d'element qui le support:`,s)},$attrState({attrValue:e,el:t,setAttribute:n}=C){let s;if(e instanceof r){const r=(e,r)=>{s instanceof Function&&s(),s=n(t,e,r??"")};return e.onChange(((e,t)=>{if(e&&"object"==typeof e)if(t&&"object"==typeof t){e.attrName===t.attrName&&e.attrValue===t.attrValue||r(e.attrName,e.attrValue??"")}else r(e.attrName,e.attrValue??"");else r(e,"");return s}),!0)}return n(t,e,!0)},$if({attrValue:e,el:t,index:n,data:s,arg:o}=C){n=Math.random(),"object"!=typeof s.listCondition&&(s.listCondition={});const i=e=>e instanceof Function?e(t):!!e,a=()=>Object.values(s.listCondition).every((e=>e)),c=(e=a())=>y(t).getTextRoot().then((n=>n.parentNode?n.parentNode&&e?n.after(t):t.remove():y(t).onConnected((()=>y(t).getTextRoot().then((()=>a()?n.after(t):t.remove()))))));return e instanceof r?e.onChange((t=>{const r=i(t);return s.listCondition[n]="false"==o?!r:r,c(),()=>{delete s.listCondition[n],e.destroy(!0)}}),!0):(s.listCondition[n]=i(e),c(),()=>s.listCondition[n]=!0)},$ref({el:e,attrValue:t}=C){if(t instanceof r&&(t=t.value),t instanceof Function)return t(e);c.isRef(t)&&(t.current=e)},$show({el:e,attrValue:t}=C){if(t instanceof r)return t.onChange((n=>(e.hidden=!n,()=>t.destroy(!0))),!0);e.hidden=!t},$bind({el:e,arg:t,modifiers:n,attrValue:s}=C){const o=[];s instanceof r&&o.push(s.onChange((n=>(t in e?e[t]=n:e.setAttribute(t,n),()=>s.destroy(!0))),!0));const i=()=>{const n=t in e?e[t]:e.getAttribute(t);s instanceof r&&s.set(n)};if(o.push(...Object.keys(n).map((t=>(e.addEventListener(t,i),()=>e.removeEventListener(t,i))))),0==Object.keys(n).length){const t=["input"].includes(e.localName)?"input":"change";e.addEventListener(t,i),o.push((()=>e.removeEventListener(t,i)))}return()=>o.map((e=>e()))},$directives({el:e,arg:t,modifiers:n,attrValue:s}=C){s instanceof r&&(s=s.value),"object"==typeof s&&Object.assign(this,s)}};initProps(e=this.refs){if(!(e instanceof x))throw new Error("refs must be an instance of RXRefs");const t=({index:e})=>this.refs[e],n=(e,t)=>{if(t in e){if(t.includes("<")&&t.includes(">")&&">"==t.at(-1)){const e=t.indexOf("<");t=t.slice(0,e)}return(()=>{let n=Math.round(1e8*Math.random());for(;t+`<${n}>`in e;)n++;return t+=`<${n}>`})()}return t};this.props=Object.entries(this.props).reduce(((e,[s,o])=>{const i=x.parse(s,this.refs),a="string"==typeof o?x.split(o??"",t):[o];!/^\s*$/.test(a[0])||a[0]instanceof r||a.shift(),!/^\s*$/.test(a.at(-1))||a[0]instanceof r||a.pop();let c,u=!1;const l=()=>{if(u)return c;if(u=!0,0==a.length)return c="","";if(1==a.length)return c=a[0],a[0];const e=h((()=>a.join("")),a);return c=e,e};if(i){let t=!1;const a=!!i.value.find((e=>(e instanceof Function&&(t=!0),e instanceof r))),c=()=>h((()=>({attrName:i.value.map((e=>e instanceof Function?e.name:e instanceof r?e.toString():"object"==typeof e?e?.constructor?.name:e)).join(""),attrValue:l()})),[...i.value]);if("$"==i.value[0]&&i.value[1]instanceof Function){const t=i.value[1],r=Math.round(1e6*Math.random()),s=("$"==t.name[0]?t.name:"$"+t.name)+"{"+r+"}";this.directives[s]=t;let o="$attrState";o=n(e,o),i.value[0]="",i.value[1]=s;const a=c();return e[o]=a,e}if(a){let t="$attrState";t=n(e,t);const r=c();return e[t]=r,e}if(t){const t=[...i.value];if(t[0]instanceof Function&&1==t.length){let r="$onInit";return r=n(e,r),e[r]=t[0],e}{let t=[...i.value].map((e=>e instanceof Function?e.name:e)).join("");return t=n(e,t),e[t]=l(),e}}if(i.value[0]instanceof Object&&1===i.value.length)return""!=o||i.value[0].constructor!==Object||Object.entries(i.value[0]).map((([t,r])=>{t=n(e,t),e[t]=r})),e;s=i.valueString}let f=!1;return":"==s[0]&&(f=!0,s=s.slice(1)),"children"==s?(e.children=o,e):(s=n(e,s),e[s]=f?h((()=>l())):l(),e)}),{})}constructor(){}type;props;#t;#n;get parent(){return this.#n}set parent(e){if(!(e instanceof j))throw new Error("parentFiber doit être une instance FiberOfNode");this.#n=e}get dom(){return this.#t}set dom(e){if(this.#t)throw new Error("dom a déja une valeur Node ");if(!(e instanceof Node))throw new Error("domValue doit être une instance de Node");this.#t=e}}class N extends j{constructor(e,t={},n=new x){if(!(n instanceof x))throw new Error("refs must be an instance of RXRefs");super(),this.type=e,this.refs=n,this.props=Object.freeze({...t,children:t.children??[]}),this.props.children.map(((e,t)=>{e instanceof DocumentFragment&&(this.props.children[t]=[...e.$children])})),this.initProps(this.refs),this.components=this.refs.components,this.components[e]&&(this.type=this.components[e]),Object.freeze(this)}}class F extends j{constructor(e,t=new x){if(!(t instanceof x))throw new Error("refs must be an instance of RXRefs");super(),this.refs=t,this.type="FRAGMENT",this.props=Object.freeze({children:e??[]}),this.initProps(this.refs),Object.freeze(this)}}class R extends j{constructor(e,t=new x){if(!(t instanceof x))throw new Error("refs must be an instance of RXRefs");return super(),this.refs=t,this.type="TEXT",this.props=Object.freeze({nodeValue:e,children:[]}),Object.freeze(this),this.props.nodeValue instanceof Node?(this.props.nodeValue instanceof DocumentFragment&&console.log([...this.props.nodeValue.$children]),this.props.nodeValue):this.props.nodeValue instanceof j?this.props.nodeValue:void 0}}const $=(e,t,n)=>e.apply(n,t);$.after=(e,t,n)=>Promise.resolve().then((()=>e.apply(n,t))),$.idle=(e,t,n)=>requestIdleCallback((()=>e.apply(n,t)));const T={set(e,t,{methode:n,value:r,textRef:s,listElement:o}){if(!Array.isArray(o))throw new Error("listElement doit être une Array");if(!Array.isArray(e))throw new Error("valueOfState doit être une Array");if(s.$firstElement=o[0],e.every((e=>e instanceof Node))){const t=[];o.splice(0,o.length,...e.map(((e,n)=>{const r=k(e);return 0==n?s.$firstElement!==r&&(s.$firstElement=r,s.after(r)):o[n]!==r&&t.at(-1).after(r),t.push(r),r}))).map((e=>!o.find((t=>t===e))&&y(e).destroy(!0)))}else o.splice(0,o.length,...e.map((e=>{const t=k(e);return s.before(t),t}))).map((e=>y(e).destroy()))}};function S(e,t){if(!(t.props.nodeValue instanceof r))return e;let n=t.props.nodeValue;const s=Array.isArray(n.value)?new DocumentFragment:e;if(t.dom=s,Array.isArray(n.value)&&s.append(e),!(e instanceof Text))throw new Error("textDom doit être une instance de Text");let o=[];return $.after((()=>function(e,t,n,r){const s=e.onChange(((n,o,{methode:i,value:a,...c})=>{if(o instanceof Node&&n!==o&&o.destroy(!0),n instanceof Node)r.splice(0,r.length).map((e=>e instanceof Node&&e.destroy())),t.data="",$.idle((()=>t.after(n))),r.push(n);else if(t.data=n,Array.isArray(n)){t.data="";const e=[n,o,{...c,methode:i,value:a,listElement:r,textRef:t}];$.after((()=>{T[i]instanceof Function?T[i](...e):T.set(...e)}))}else if(n instanceof j){t.data="",r.splice(0,r.length).map((e=>e instanceof Node&&e.destroy()));const e=k(n);r.push(e),e.onDestroy((()=>r.length&&s()));let o=!1;const i=(e,t,n=!1)=>!(!o||n)||!!e.parentNode&&(e.after(t),o=!0,!0),a=()=>{if(i(t,e),!o)return requestIdleCallback(a)};requestIdleCallback(a),t.onConnected((n=>{if(n instanceof Node&&t.parentNode!==n)return n.append(t),i(t,e,!0);i(t,e)}))}else if("object"==typeof n)try{t.data=JSON.stringify(n,null,20)}catch(e){}return(n=!0)=>{t.data="",r.map((e=>e.destroy(n))),o instanceof Node&&o.destroy(),n&&(t.remove(),e.destroy(!0))}}),!0);y(n).onCleanup(s)}(n,e,s,o))),s}const O=["style","link"];function V(e,t=document.body){if("string"==typeof t&&(t=document.querySelector(t)),!(t instanceof Node))throw new Error("container doit être de type Node");let n;const r=function(e){if(!(e instanceof Node))throw new Error("container doit être de type Node");const t=new Text("");return e.shadowRoot?e.shadowRoot.append(t):e.append(t),t}(t);function s(e){if(Array.isArray(e))return n=e.map((e=>V(e,t))),n;y(t).onCleanup(y(e).onCleanup);r.after(e),y(e).dispatchConnected(t),r.remove(),n=e}if(((e,t)=>!!O.includes(String(e?.type).toLowerCase())||!!O.includes(t.localName)||void 0)(e,t)){s(k(e))}return async function(){if(n)return n;if(!(t instanceof Node))throw new Error("container doit etre un instance de Node");return s(await $.after((()=>k(e)))),n}()}function k(e){if(e instanceof j&&e.dom instanceof Node)throw new Error("fibre a déja une instance dom, fais une copie du fibre si vous voulez une autre instance");if(Array.isArray(e))return e.flat(1/0).map((e=>k(e)));e instanceof Function?e=new N(e,{children:[]}):e instanceof EventTarget||e instanceof j||(e=new R(e));const t=function(e){const t=e=>e.flat(1/0).map((e=>k(e)));if(e instanceof Node)return e;if(e instanceof j&&e.dom instanceof Node)return e.dom;if(e instanceof F)return t(e.props.children);if(e instanceof R)return Array.isArray(e.props.nodeValue)?t(e.props.nodeValue):e.props.nodeValue instanceof Node?e.props.nodeValue:new Text(e.props.nodeValue);if(e instanceof N){if(e.components[e.type]instanceof Function){const t=e.components[e.type];e.type=t}if(e.type instanceof Function){let t=e.props;return"object"==typeof e.type.defaultProps&&(t={...e.type.defaultProps,...t}),k(e.type(t))}return document.createElement(e.type)}if(Array.isArray(e))return t(e);if(e instanceof Function){let t={children:[]};return"object"==typeof e.defaultProps&&(t={...e.defaultProps,children:[]}),k(e(t))}if(e instanceof r)return k(new R(e,new x));try{return new Text(JSON.stringify(e))}catch(t){return new Text(e)}}(e);e instanceof j&&t instanceof Node&&!(t.fiber instanceof j)&&Object.defineProperty(t,"fiber",{get:()=>e});if(Array.isArray(t)){if(e.parent instanceof j)return t;const n=new DocumentFragment;return n.append(...t),n}return(t=>{if(e instanceof Node)return t;if(e instanceof R&&r.isState(e.props.nodeValue))return S(t,e);if(e&&e.type instanceof Function)return t;const n=[];if(e instanceof j){if(e.dom=t,!e.props.children)return t;n.push(...e.props.children.flat(1/0).map((n=>("object"!=typeof e.components&&(console.warn("fiber.component doit être une object"),e.components={}),n instanceof j&&(n.parent=e,Object.assign(n.directives,e.directives),n.components=e.components),V(n,t)))))}return Promise.all(n).then((n=>{!function(e,t){if(!(e instanceof Node))throw new Error("dom doit etre un element node");if(!(e instanceof HTMLElement))return null;if(t&&t.type instanceof Function)return null;if(!(t instanceof N))return null;const n={},s={},o=(e,[i,a],c,u=[])=>{const l=(e,t=c,n=i)=>{if(!/^\s*$/.test(n)){if(t instanceof HTMLSelectElement&&["multiple"].includes(n))t.multiple=!0;else{if(["disabled","hidden"].includes(n))return t[n]=""===e||e;if(n in t||["object","function"].includes(typeof e))return"object"==typeof e&&"object"==typeof t[n]?Object.assign(t[n],e):t[n]=e}t.setAttribute(n,e)}},f=(t,n,r)=>{const s=[];return o(e,[n,r],t,s),()=>$((()=>s.map((e=>e instanceof Function&&e()))))},d=(e,t)=>{const n=t=>{t instanceof r?y(c).onCleanup(t.onChange(((n,r)=>(e(n,r),()=>t.destroy())),!0)):e(t)};Array.isArray(a)?a.map((e=>n(e))):n(a),y(c).onCleanup((()=>t instanceof Function&&t()))},p=()=>null;let h,m=p;const g=a,b=/^([^<>]+)<\d+>$/.exec(i);if(b&&(i=b[1]),"children"==i||!(t instanceof N))return e;if("string"!=typeof i)return e;if(i&&(i.startsWith("on")||i.startsWith("@"))){let t=i.slice(i.startsWith("on")?2:1).toLowerCase();t.indexOf("<")>-1&&(t=t.slice(0,t.indexOf("<")));const n=(e,t=[])=>(e instanceof r&&(e=e.isDestroyed?()=>null:e.value),e(...t)),s=(...e)=>{if(Array.isArray(a))return a.map((t=>n(t,e)));n(a,e)};let o=()=>c.removeEventListener(t,s);return y(c).onCleanup(o),c.addEventListener(t,s),m=()=>o,e}if("."==i[0]){const t=c[i.slice(1)];return c[i.slice(1)]=a,m=()=>c[i.slice(1)]=t,e}if(h=/^(?<name>(?:\$|\:)[^\s</>\:\[\]]+)(?:\:(?<arg>[^\s</>:\[\]]*)(\[(?<modifiers>[^\s</>\[\]]*)\])?)?(?:\<(?<index>\d+)\>)?$/.exec(i)){const{name:r,arg:o,modifiers:l}=h.groups;if(s[r]=r in s?s[r]+1:0,t.directives[r]instanceof Function){let e=s[r];(["$ref"].includes(r)?$:$.after)((()=>{n[r]||(n[r]={});const s=t.directives[r]({setAttribute:f,globalData:n,data:n[r],el:c,attrName:i,attrValue:a,index:e?Number(e):0,directiveName:r,arg:o,modifiers:l?.split(",").reduce(((e,t)=>(e[t]=!0,e)),{})||{}});s instanceof Function&&(y(c).onCleanup(s),m=s,u.push(m))}))}return e}if(["input","select","textarea"].includes(c.localName)&&["value","checked"].includes(i)&&g instanceof r){["select"].includes(c.localName)&&c instanceof HTMLSelectElement&&(c.value=g.value,y(c).onReady((()=>{c.selectedIndex=-1;let e=-1;for(let t of c)e++,t.value===g.value&&(c.selectedIndex=e)})));const e=e=>$.after((()=>["checkbox"].includes(e.target.type)?g.set(e.target.checked):g.set(e.target[i])));c.addEventListener("input",e),m=()=>{c.removeEventListener("input",e),c.value=""},y(c).onCleanup(m)}else{if("style"==i||/^style<\d+>/.test(i)){const t=c.style.cssText,n=e=>$.after((()=>{e instanceof Object?Object.assign(c.style,e):c.style.cssText+=e}));return d(n,(()=>n(t))),e}if("class"==i||/^class\<\d+\>/.test(i)){const t=c.getAttribute("class"),n=(e,t)=>$.after((()=>{const n=e=>String(e).split(" ").map((e=>e&&c.classList.add(e))),r=e=>String(e).split(" ").map((e=>e&&c.classList.remove(e)));Array.isArray(t)?t.map((e=>r(e))):r(t),Array.isArray(e)?e.map((e=>n(e))):n(e)}));return d(n,(()=>n(t))),e}if(i&&i.startsWith("?")){if(i=/^([^<>]+)\<\d+\>/.test(i)?i.slice(0,i.indexOf("<")):i,!a)return e;let t;const n=e=>{const t=e=>f(c,i.slice(1),e);if("object"!=typeof a)return t(e);{const{when:n,value:s}=e;if(n instanceof r){let e;return n.onChange((n=>(n?e||(e=t(s instanceof r?s.get():s)):(e&&e(),e=null),()=>e&&e())),!0)}if(n)return t(s)}};a instanceof r||(t=n(a));const s=()=>t();return s instanceof Function&&(c.onDestroy(s),m=s,u.push(m)),e}}if(a instanceof r){const e=a,t=e.onChange((t=>(l(t),()=>{e.destroy(!0),c.removeAttribute(i)})));y(c).onCleanup(t),a=a.value,u.push(t)}return l(a),m===p&&(m=()=>{c.removeAttribute(i)}),u.push(m),e};Object.entries(t.props).reduce(((t,[n,r])=>o(t,[n,r],e)),{})}(t,e),$.after((()=>y(t).dispatchReady(t,n)))})),t})(t)}function D(e,t={defaultProps:{}}){if("object"!=typeof t)throw new Error("option doit être une de type object");const n=t.defaultProps??{};if("object"!=typeof n)throw new Error("option.defaultProps doit être une de type object");const r=t=>e(f({...n,...t}));return r.defaultProps=n,r}const P=new WeakMap,L={defaultProps:{},shadowRoot:null};function M(e,t,n=L){const{defaultProps:r=L.defaultProps,shadowRoot:s=L.shadowRoot}=n,o=class extends HTMLElement{static get observedAttributes(){return Object.keys(r)}attributeChangedCallback(e,t,n){const r=P.get(this).props;i.isState(r[e])&&r[e].toString()!=n&&"object"!=typeof r[e].value&&(r[e].set(n),console.log(e,n))}constructor(e){super(),e="object"==typeof e&&e?e:{};const s={connectedCallback:p(),disconnectedCallback:p(),adoptedCallback:p(),onCleanup:[()=>{}],mounted:p({onSubscribe:e=>(...t)=>{const n=e(t);n instanceof Function&&this.onCleanup(n)}}),props:e,children:[]};P.set(this,s),y(this),Array.isArray(e.children)&&s.children.push(...e.children);const o=n.shadowRoot?this.attachShadow({mode:"closed"===n.shadowRoot?.mode?"closed":"open",delegatesFocus:!!n.shadowRoot?.delegatesFocus,slotAssignment:"manual"===n.shadowRoot?.slotAssignment?"manual":"named"}):this;y(o);const a=Object.freeze({root:o,el:this,...Object.entries(s).reduce(((e,[t,n])=>(Array.isArray(n)&&(e[t]=n[0]),e)),{})});setTimeout((()=>{Promise.resolve().then((()=>{for(let t of this.attributes){const n=t.name;i.isState(e[n])?e[n].set(t.value):e[n]=t.value}s.props=f({...r,...e}),s.children.push(...this.childNodes);const n=t({...s.props,children:[...s.children]},a);o.append(k(n)),s.mounted[1](this),this.isConnected&&s.connectedCallback[1]()}))}))}connectedCallback(){P.get(this).connectedCallback[1]()}disconnectedCallback(){P.get(this).disconnectedCallback[1]()}adoptedCallback(){P.get(this).adoptedCallback[1]()}};return customElements.define(e,o,{}),e=>new o({children:[],...e})}const I=["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"],q=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","marquee","menu","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","slot","small","source","span","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"],X=/(<(?:\/\s*)?(?:[^\!<>\s"'=\/\\]+)\s*(?:(?:\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*"[^"]*"|\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*'[^']*'|\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*[^<>\s"'=\/\\]+|\s*(?<="|'|\s)[^<>\s"'=\/\\]+?)*)\s*(?:\/)?\s*>)/,z=/<(?<isClosingTag>\/\s*)?(?<type>[^\!<>\s"'=\/\\]+)\s*(?<attr>(?:\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*"[^"]*"|\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*'[^']*'|\s*(?<="|'|\s)[^<>\s"'=\/\\]+\s*=\s*[^<>\s"'=\/\\]+|\s*(?<="|'|\s)[^<>\s"'=\/\\]+?)*)\s*(?<isAutoClose>\/)?\s*>/,H=/^(?<attrName>[^<>\s"'`=\/\\]+)$/,_=/(?<="|'|`|\s*)[^<>\s"'`=\/\\]+\s*/,G=/^(?<attrName>[^<>\s"'`=\/\\]+)\s*=\s*"(?<attrValue>[^"]*)"$/,W=v(_,/\s*=\s*/,/"[^"]*"/),J=/^(?<attrName>[^<>\s"'`=\/\\]+)\s*=\s*'(?<attrValue>[^']*)'$/,K=v(_,/\s*=\s*/,/'[^']*'/),B=/^(?<attrName>[^<>\s"'`=\/\\]+)\s*=\s*`(?<attrValue>[^`]*)`$/,Q=v(_,/\s*=\s*/,/`[^`]*`/),U=/^(?<attrName>[^<>\s"'`=\/\\]+)\s*=\s*(?<attrValue>[^<>\s"'`=\/\\]+)$/,Y=E(W,K,Q,v(_,/\s*=\s*/,/[^<>\s"'`=\/\\]+/),/\s+/);function Z(e){const t=z.exec(e);return t?!t.groups.isClosingTag:null}function ee(e){const t=(e,t,n)=>{const r=(r=n,s=t)=>{if(e[s]){let t=Math.round(1e8*Math.random());for(;s+`<${t}>`in e;)t++;return e[s+`<${t}>`]=r,e[s]}return r};return t.startsWith("?")||t.startsWith("on")||["style","class"].includes(t)||/^(?<name>\$[^\s</>:\[\]]+)(?:\:(?<arg>[^\s</>:\[\]]*)(\[(?<modifiers>[^\s</>\[\]]*)\])?)?(?:\<(?<index>\d+)\>)?$/.exec(t)?r():isNaN(n)?n:Number(n)};return e.split(Y).reduce(((e,n)=>{if(/^\s*$/.test(n))return e;let r;return(r=G.exec(n))||(r=J.exec(n))||(r=B.exec(n))||(r=U.exec(n))?e[r.groups.attrName]=t(e,r.groups.attrName,r.groups.attrValue):(r=H.exec(n))&&(e[r.groups.attrName]=""),e}),{})}function te(e){const t=z.exec(e);if(!t)return null;const{type:n,attr:r,isAutoClose:s,isClosingTag:o}=t.groups;return{get isTagEmpty(){return I.includes(this.type)},get isTagKnown(){return q.includes(this.type)},type:n,attr:r,isAutoClose:s,isClosingTag:o,htmlTag:e,props:ee(t.groups.attr),initType(e){if(!(e instanceof x))throw new Error("rxRefs must be instance of RXRefs");const t=x.parse(this.type,e);if(t&&2==t.value.length&&":"==t.value[0].at(-1)&&t.value[1]instanceof Function)return this.type=t.value[0].slice(0,-1),e.components[this.type]=t.value[1],this.type;let n=x.split(this.type,(({index:t})=>e[t]));return n=1===n.length?n[0]:n.join(""),"string"!=typeof n&&"function"!=typeof n&&(n=typeof n+".is-not-component-valid"),this.type=n}}}function ne(e,t,n){for(;t.length;){const s=t.shift();if(!/^\s*$/.test(s))if(Z(s)){const o=te(s);o.children=[],o.initType(n),r=o.type,I.includes(r?.toLowerCase?.())||o.isAutoClose||re(o,t,n);const i=new N(o.type,{...o.props,children:o.children},n);e.push(i)}else{const t=s.split(E(x.regExp,/{{[^{}]*}}/));/^\s*$/.test(t[0])&&t.shift(),/^\s*$/.test(t.at(-1))&&t.pop(),e.push(...t.map((e=>{const t="string"==typeof e?x.parse(e,n):e;if("string"!=typeof(e=t?t.value[0]:e))return e;const r=e=>/\s*\<\!--.*--\>\s*/.test(e);return r(e)?e.split(/(\s*\<\!--.*--\>\s*)/).map((e=>r(e)?document.createComment(/^\s*\<\!--(.*)--\>\s*$/.exec(e)[1]):e)).filter((e=>e)):new R(e,n)})))}}var r;return e}function re(e,t,n){if(e.type instanceof Function&&!e.type.name)return;let r=1;const s=t.findIndex((t=>{const s=te(t),o=x.parse(s?s.type:t,n);return!!(s&&(o&&o.value[0]===e.type||s.type===e.type)&&(r=s.isClosingTag?r-1:r+1,s.isClosingTag&&r<=0))}));if(-1===s?e.children=t.splice(0,t.length).filter((e=>!/^\s*$/.test(e))):(e.children=t.splice(0,s+1).filter((e=>!/^\s*$/.test(e))),e.children.pop()),"script"==e.type){let t=e.children.join("");const r=x.parse(t,n);r&&(t=r.valueString),e.children=[new Text(t)]}else e.children=ne([],e.children,n)}function se(e,t){if(!(t instanceof x))throw new Error("rxRefs must be instance of RXRefs");const n=function(e){return e.split(X)}(e),r=ne([],n,t);if(1==r.length){const e=r[0];return e instanceof j?e:new R(e,t)}return new F(r,t)}function oe(e,...t){let n;"object"==typeof t[0]&&!0===t[0]["<isStore>"]&&(n=t[0],t[0]="");const[r]=function(e,...t){return[[...t.reduce(((n,r,s)=>(n.push(e[s],`(_|-[RXRefs{index:${s},type:${typeof t[s]}}]-|_)`),n)),[]),e[t.length]].join(""),t]}(e,...t),s=se(r,new x(...t));return n&&(n.components&&"object"==typeof n.components&&(s.components=n.components),n.directives&&"object"==typeof n.directives&&(s.directives=n.directives)),s}function ie(...e){return k(oe(...e))}const ae=(e,t,n)=>e.apply(n,t);ae.after=(e,t,n)=>Promise.resolve().then((()=>e.apply(n,t))),ae.idle=(e,t,n)=>requestIdleCallback((()=>e.apply(n,t)));function ce(e,t,...n){const r=new LinksOfDataInTemplateString;return t=t??{children:[]},n=n.map((e=>e instanceof RcHtmlNode?e:new RcHtmlText(e,r))),"FRAGMENT"==e?new RcHtmlFragment(n,r):"TEXT"==e?new RcHtmlText(n,r):new RcHtmlElement(e,{...t,children:n},r)}ce.Fragment="FRAGMENT",ce.Text="TEXT",ie.map=function(e,t){const n=e instanceof r?[...e.value]:e;var[e,s]=i(e,(e=>(n.splice(0,n.length,...e),n)));const o=(e,t)=>[i(e)[0],i(t)[0]],a=n=>t(...n,e,(e=>{const[t,r]=n;return s.edit(r,e)})),c=e.value.map(o);let u=ae.after((()=>c.map(a)));const[l,f]=i(u);return l.onChange((e=>ae.after((()=>{if(!(e instanceof Promise||e.every((e=>e instanceof Node))))throw new Error("html.map doit retourner des list d'element Node")}))),!0),e.onChange((t=>{if(c.length>t.length){const e=t.length,n=c.length;c.splice(e,n).map((e=>e.map((e=>e.destroy(!0))))),f.splice(e,n)}else if(c.length<t.length){const e=c.length;c.push(...t.slice(e).map(o)),c.map((([,e],t)=>e.set(t))),f.push(...c.slice(e).map(a))}c.map((([t,n],r)=>ae.after((()=>{n.isDestroyed||n.set(r),t.isDestroyed||t.set(e.value[r])}))))})),l};export{N as FiberOfElement,F as FiberOfFragment,j as FiberOfNode,R as FiberOfText,x as LinksOfDataInTemplateString,r as RXState,D as component,k as createDom,ce as createFiber,M as define,ie as html,V as render,oe as template,u as useEffect,p as useEvent,l as useLayoutEffect,h as useMemo,f as useProps,c as useRef,i as useState};
//# sourceMappingURL=rimax.es.min.js.map
